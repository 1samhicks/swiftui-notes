[#patterns]
= Patterns and Recipes

[#patterns-creating-subscriber]
== Creating a subscriber with `.sink`

If you are creating the subscriber, you can use `.sink()`` to receive and process this information.
The simplest form of `.sink()` takes a single closure - but by default this is the closure that receives data (if provided by the pipeline).
If you don't also include a closure to get the completion, you will not receive any information about failures.

[IMPORTANT]
====
Remember that the subscriber drives the execution of any Combine pipelines you create. When you create and connect a subscriber with `.sink()`, it will connect and set up a request for unlimited data.

When you create your sink methods, be aware that your receiveValue closure may be called repeatedly, depending on what the publisher or pipeline does and how it is configured.
====

A simple sink that ignores the errors and triggers on data might be:

[source, swift]
----
let _ = remoteDataPublisher.sink { value in
    print(".sink() received \(String(describing: value))")
}
----

A more complete form of a subscriber has the two closures:

[source, swift]
----
let _ = remoteDataPublisher.sink(receiveCompletion: { err in
    print(".sink() received the completion", String(describing: err))
}, receiveValue: { value in
    print(".sink() received \(String(describing: value))")
})
----

If you want to handle the error in the subscriber, you can `switch` on the returned completion to determine if it is `.finished` or `.failure`.

[source, swift]
----
.sink(receiveCompletion: { completion in
    switch completion {
    case .finished:
        // no associated data, but you can react to knowing the request has been completed
        break
    case .failure(let anError):
        // do what you want with the error details, presenting, logging, or hiding as appropriate
        print("GOT THE ERROR: ", anError)
        break
    }
}, receiveValue: { someValue in
    // do what you want with the resulting value passed down
    // be aware that depending on the data type being returned, you may get this closure invoked
    // multiple times.
    print(".sink() received \(someValue)")
})
----


[#patterns-sequencing-async]
== sequencing async operations

There are a variety of ways to chain together asynchronous operations.
Combine adds to this variety, and is effective when you want to use the data from one operation as the input to the next.
If you are familiar with using Promises in another language, such as Javascript, this pattern is roughly the equivalent of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Chaining[Promise chaining].
The benefit to using Combine is that the sequencing can be relatively easy to parse visually.

[#patterns-sequencing-dataTaskPublisher]
=== Making a network request with dataTaskPublisher

One of the common use cases is requesting JSON data from a URL and decoding it.
This can be readily accomplished with Combine using https://developer.apple.com/documentation/foundation/urlsession/3329708-datataskpublisher[dataTaskPublisher] on https://developer.apple.com/documentation/foundation/urlsession[URLSession].
The data that is returns down the pipeline is a tuple: `(data: Data, response: URLResponse)`

The simplest case of using this might be:

[source, swift]
----
struct IPInfo: Codable {
    // matching the data structure returned from ip.jsontest.com
    var ip: String
}
let myURL = URL(string: "http://ip.jsontest.com")
// NOTE(heckj): you'll need to enable insecure downloads in your Info.plist for this example

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .map({ (inputTuple) -> Data in
        return inputTuple.data
    })
    .decode(type: IPInfo.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
----

The subscriber will get either the data, or receiving a completion notification with an error.
The dataTaskPublisher will make a single request, and what you build in the pipeline will determine what the subscriber receives.

In the above example, a failed URL request will result in a `.failure` completion with an encapsulated error.
Likewise, if the returned data couldn't be decoded based on the structure, or wasn't JSON, then the result will be a `.failure` completion with an encapsulated decoding error from the decoder.

If you want to have more control over what is considered a failure in the URL response, you use a tryMap on the tuple response from dataTaskPublisher.
An example of that might look like:

[source, swift]
----
struct IPInfo: Codable {
    // matching the data structure returned from ip.jsontest.com
    var ip: String
}
let myURL = URL(string: "http://ip.jsontest.com")
// NOTE(heckj): you'll need to enable insecure downloads in your Info.plist for this example

enum testFailureCondition: Error {
    case invalidServerResponse
}

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .tryMap { data, response -> Data in
        // this give you the full capability to react to both the data and the HTTPURLResponse
        // with the expectation that you will throw an error if a failure completion is warranted.
        guard let httpResponse = response as? HTTPURLResponse,
            // this will casue an .failure completion on anything other than a 200 response
            httpResponse.statusCode == 200 else {
                throw testFailureCondition.invalidServerResponse
        }
        return data
    }
    .decode(type: IPInfo.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
----

[#patterns-general-error-handling]
== Handling errors in the pipline

The examples above expected that the subscriber would handle the error conditions, if they occured.
However, you are not always able to control the subscriber - as might be the case if you're using SwiftUI view properties as the subscriber, and you're providing the publisher.

=== using the `assertNoFailure` operator

The most brutal way to handle this is to crash the application when an error happens.
Combine provides the operator `assertNoFailure()` for this purpose.
This is useful if you are sure you handled the errors and need to map a pipeline which technically can generate a failure type of `<Error>` to a subscriber that requires a failure type of `<Never>`.

Adding it into the pipeline requires no additional parameters, but you can include a string:

[source, swift]
----
.assertNoFailure()
// OR
.assertNoFailure("What could possibly go wrong?")
----

[NOTE]
====
I'm not entirely clear on where that string would appear if you did include it.

When trying out this code in unit tests, the tests invariably drop into a debugger at the assertion point when a .failure is processed through the pipeline.
====

=== using `catch` operator

The `.catch()` operator is useful to recover from an error, but it's a bit quirky.
It handles errors by replacing the upstream publisher with another publisher that you provide as a return in a closure.
This effectively terminates the earlier portion of the pipeline.

For example, with this code snippet illustrates what happens:

[source, swift]
----
enum testFailureCondition: Error {
    case invalidServerResponse
}

let simplePublisher = PassthroughSubject<String, Error>()

let _ = simplePublisher
    .catch { err in
        // must return a Publisher
        return Publishers.Just("replacement value")
    }
    .sink(receiveCompletion: { fini in
        print(".sink() received the completion:", String(describing: fini))
    }, receiveValue: { stringValue in
        print(".sink() received \(stringValue)")
    })

simplePublisher.send("oneValue")
simplePublisher.send("twoValue")
simplePublisher.send(completion: Subscribers.Completion.failure(testFailureCondition.invalidServerResponse))
simplePublisher.send("redValue")
simplePublisher.send("blueValue")
simplePublisher.send(completion: .finished)
----

The values you would see printed are:

[source]
----
.sink() received oneValue
.sink() received twoValue
.sink() received replacement value
.sink() received the completion: finished
----

When the failure was sent through the pipeline, catch intercepted it and returned "replacement value" as expected, but the replacement publisher it used (`Publishers.Just`) sends a single value and then sending a completion.

It's worth mentioning that there is also a `tryCatch()` operator, which supports you doing your own analysis on the error and potentially throwing a new/different failure condition down the chain.
Like `catch()` it also replaces the publisher.

=== using `flatMap` with `catch` to handle failures

A more general solution to handling the errors is also a bit more complex.
It leverages the `flatMap()` operator, which transforms all elements from an upstream publisher into a new or existing publisher.
We can use `flatMap()` operator along with the `just()` publisher and `catch()` operator to bring in placeholder values only when needed and otherwise keep the pipeline operational.

diagram version:

[source]
----
publisher -> flatMap -> (                                           ) -> subscriber
                         Just -> decode -> catch (                 )
                                                  Just(fallback) ->
----

[source, swift]
----
let trickNamePublisher = NotificationCenter.default.publisher(for: .newTrickDownloaded)
.map { notification in
    return notification.userInfo?["data"] as! Data
}
.flatMap { data in
    return Just(data)
    .decode(MagicTrick.self, JSONDecoder())
    .catch {
        return Just(MagicTrick.placeholder)
    }
}
.publisher(for: \.name)
.receive(on: RunLoop.main)
----


replace `decode` with any operator that might return an error

=== using the `retry` operator

* (mention idempotency issues here)

image fallback under constrained network

[source, swift]
----
// Generalized Publisher for Adaptive URL Loading
func adaptiveLoader(regularURL: URL, lowDataURL: URL) -> AnyPublisher<Data, Error> {
    var request = URLRequest(url: regularURL)
    request.allowsConstrainedNetworkAccess = false
    return URLSession.shared.dataTaskPublisher(for: request)
        .tryCatch { error -> URLSession.DataTaskPublisher in
            guard error.networkUnavailableReason == .constrained else {
               throw error
            }
            return URLSession.shared.dataTaskPublisher(for: lowDataURL)
        .tryMap { data, response -> Data in
            guard let httpResponse = response as? HTTPUrlResponse,
                   httpResponse.status_code == 200 else {
                       throw MyNetworkingError.invalidServerResponse
            }
            return data
}
.eraseToAnyPublisher()
----


the general failure, fallback pattern

* URLSession data gathering when on a constrained network
* URLSession returning placeholder data when service unavailable

[#patterns-binding]
== binding

binding to objects to get data from them

simple case - data validation with external service

[source, swift]
----
@Published var username: String = ""

var validatedUsername: AnyPublisher<String?, Never> {
    return $username
        .debounce(for: 0.5, scheduler: RunLoop.main)
           //  <String?>|<Never>
        .removeDuplicates()
           //  <String?>|<Never>
        .flatMap { username in
            return Future { promise in
                self.usernameAvailable(username) { available in
                   promise(.success(available ? username : nil))
                }
          //    <Result<Output, Failure>>
            }
        }
          // <String?>|<Never>
        .eraseToAnyPublisher()
}
----

validation - listening for changes to validate them together

[source, swift]
----
@Published var password: String = ""
@Published var passwordAgain: String = ""

var validatedPassword: AnyPublisher<String?, Never> {
    return CombineLatest($password, $passwordAgain) { password, passwordAgain in
        guard password == passwordAgain, password.count > 8 else { return nil }
        return password
    }
      //  <String?>|<Never>
    .map { $0 == password1 ? nil : $0 }
      //  <String?>|<Never>
    .eraseToAnyPublisher()
      //  <String?>|<Never>
}
----

more complex validation - bringing together substreams

[source, swift]
----
var validatedCredentials: AnyPublisher<(String, String)?, Never> {
    return CombineLatest(validatedUsername, validatedPassword) { username, password in
        guard let uname = username, let pwd = password else { return nil }
        return (uname, pwd)
    }
    .eraseToAnyPublisher()
}

@IBOutlet var signupButton: UIButton!

var signupButtonStream: AnyCancellable?

override func viewDidLoad() {
    super.viewDidLoad()
    self.signupButtonStream = self.validatedCredentials
        .map { $0 != nil }
        .receive(on: RunLoop.main)
        .assign(to: \.isEnabled, on: signupButton)
}
----

* binding with models

* binding with notifications

* binding to RealityKit

binding to objects to send data to them

* binding to SwiftUI
** validating forms
** UX responsiveness - live updates to view properties
** handling error within property update
** retry for remote service


[#patterns-testing]
== testing

test strategies with combine

** testing streams/pipelines
** testing publishers
** testing subscribers

using PassthroughSubject and creative sinks