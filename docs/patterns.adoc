[#patterns]
= Patterns and Recipes

[#patterns-creating-subscriber]
== Creating a subscriber with `.sink`

If you are creating the subscriber, you can use `.sink()`` to receive and process this information.
The simplest form of `.sink()` takes a single closure - but by default this is the closure that receives data (if provided by the pipeline).
If you don't also include a closure to get the completion, you will not receive any information about failures.

[IMPORTANT]
====
Remember that the subscriber drives the execution of any Combine pipelines you create. When you create and connect a subscriber with `.sink()`, it will connect and set up a request for unlimited data.

When you create your sink methods, be aware that your receiveValue closure may be called repeatedly, depending on what the publisher or pipeline does and how it is configured.
====

A simple sink that ignores the errors and triggers on data might be:

[source, swift]
----
let _ = remoteDataPublisher.sink { value in
    print(".sink() received \(String(describing: value))")
}
----

A more complete form of a subscriber has the two closures:

[source, swift]
----
let _ = remoteDataPublisher.sink(receiveCompletion: { err in
    print(".sink() received the completion", String(describing: err))
}, receiveValue: { value in
    print(".sink() received \(String(describing: value))")
})
----

If you want to handle the error in the subscriber, you can `switch` on the returned completion to determine if it is `.finished` or `.failure`.

[source, swift]
----
.sink(receiveCompletion: { completion in
    switch completion {
    case .finished:
        // no associated data, but you can react to knowing the request has been completed
        break
    case .failure(let anError):
        // do what you want with the error details, presenting, logging, or hiding as appropriate
        print("GOT THE ERROR: ", anError)
        break
    }
}, receiveValue: { someValue in
    // do what you want with the resulting value passed down
    // be aware that depending on the data type being returned, you may get this closure invoked
    // multiple times.
    print(".sink() received \(someValue)")
})
----


[#patterns-sequencing-async]
== sequencing async operations

There are a variety of ways to chain together asynchronous operations.
Combine adds to this variety, and is effective when you want to use the data from one operation as the input to the next.
If you are familiar with using Promises in another language, such as Javascript, this pattern is roughly the equivalent of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Chaining[Promise chaining].
The benefit to using Combine is that the sequencing can be relatively easy to parse visually.

[#patterns-sequencing-dataTaskPublisher]
=== Making a network request with dataTaskPublisher

One of the common use cases is requesting JSON data from a URL and decoding it.
This can be readily accomplished with Combine using https://developer.apple.com/documentation/foundation/urlsession/3329708-datataskpublisher[dataTaskPublisher] on https://developer.apple.com/documentation/foundation/urlsession[URLSession].
The data that is returns down the pipeline is a tuple: `(data: Data, response: URLResponse)`

The simplest case of using this might be:

[source, swift]
----
struct IPInfo: Codable {
    // matching the data structure returned from ip.jsontest.com
    var ip: String
}
let myURL = URL(string: "http://ip.jsontest.com")
// NOTE(heckj): you'll need to enable insecure downloads in your Info.plist for this example

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .map({ (inputTuple) -> Data in
        return inputTuple.data
    })
    .decode(type: IPInfo.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
----

The subscriber will get either the data, or receiving a completion notification with an error.
The dataTaskPublisher will make a single request, and what you build in the pipeline will determine what the subscriber receives.

In the above example, a failed URL request will result in a `.failure` completion with an encapsulated error.
Likewise, if the returned data couldn't be decoded based on the structure, or wasn't JSON, then the result will be a `.failure` completion with an encapsulated decoding error from the decoder.

If you want to have more control over what is considered a failure in the URL response, you use a tryMap on the tuple response from dataTaskPublisher.
An example of that might look like:

[source, swift]
----
struct IPInfo: Codable {
    // matching the data structure returned from ip.jsontest.com
    var ip: String
}
let myURL = URL(string: "http://ip.jsontest.com")
// NOTE(heckj): you'll need to enable insecure downloads in your Info.plist for this example

enum testFailureCondition: Error {
    case invalidServerResponse
}

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .tryMap { data, response -> Data in
        // this give you the full capability to react to both the data and the HTTPURLResponse
        // with the expectation that you will throw an error if a failure completion is warranted.
        guard let httpResponse = response as? HTTPURLResponse,
            // this will casue an .failure completion on anything other than a 200 response
            httpResponse.statusCode == 200 else {
                throw testFailureCondition.invalidServerResponse
        }
        return data
    }
    .decode(type: IPInfo.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
----

[#patterns-general-error-handling]
== Handling errors in the pipline

assertNoError

general failure handing pattern with flatMap

[source, swift]
----
let trickNamePublisher = NotificationCenter.default.publisher(for: .newTrickDownloaded)
.map { notification in
    return notification.userInfo?["data"] as! Data
}
.flatMap { data in
    return Just(data)
    .decode(MagicTrick.self, JSONDecoder())
    .catch {
        return Just(MagicTrick.placeholder)
    }
}
.publisher(for: \.name)
.receive(on: RunLoop.main)
----

diagram version:

[source]
----
flatMap -> (                                           ) -> subscriber
            Just -> decode -> catch (                 )
                                     Just(fallback) ->
----

replace `decode` with any operator that might return an error

retry

* (mention idempotency issues here)

image fallback under constrained network

[source, swift]
----
// Generalized Publisher for Adaptive URL Loading
func adaptiveLoader(regularURL: URL, lowDataURL: URL) -> AnyPublisher<Data, Error> {
    var request = URLRequest(url: regularURL)
    request.allowsConstrainedNetworkAccess = false
    return URLSession.shared.dataTaskPublisher(for: request)
        .tryCatch { error -> URLSession.DataTaskPublisher in
            guard error.networkUnavailableReason == .constrained else {
               throw error
            }
            return URLSession.shared.dataTaskPublisher(for: lowDataURL)
        .tryMap { data, response -> Data in
            guard let httpResponse = response as? HTTPUrlResponse,
                   httpResponse.status_code == 200 else {
                       throw MyNetworkingError.invalidServerResponse
            }
            return data
}
.eraseToAnyPublisher()
----


the general failure, fallback pattern

* URLSession data gathering when on a constrained network
* URLSession returning placeholder data when service unavailable

[#patterns-binding]
== binding

binding to objects to get data from them

simple case - data validation with external service

[source, swift]
----
@Published var username: String = ""

var validatedUsername: AnyPublisher<String?, Never> {
    return $username
        .debounce(for: 0.5, scheduler: RunLoop.main)
           //  <String?>|<Never>
        .removeDuplicates()
           //  <String?>|<Never>
        .flatMap { username in
            return Future { promise in
                self.usernameAvailable(username) { available in
                   promise(.success(available ? username : nil))
                }
          //    <Result<Output, Failure>>
            }
        }
          // <String?>|<Never>
        .eraseToAnyPublisher()
}
----

validation - listening for changes to validate them together

[source, swift]
----
@Published var password: String = ""
@Published var passwordAgain: String = ""

var validatedPassword: AnyPublisher<String?, Never> {
    return CombineLatest($password, $passwordAgain) { password, passwordAgain in
        guard password == passwordAgain, password.count > 8 else { return nil }
        return password
    }
      //  <String?>|<Never>
    .map { $0 == password1 ? nil : $0 }
      //  <String?>|<Never>
    .eraseToAnyPublisher()
      //  <String?>|<Never>
}
----

more complex validation - bringing together substreams

[source, swift]
----
var validatedCredentials: AnyPublisher<(String, String)?, Never> {
    return CombineLatest(validatedUsername, validatedPassword) { username, password in
        guard let uname = username, let pwd = password else { return nil }
        return (uname, pwd)
    }
    .eraseToAnyPublisher()
}

@IBOutlet var signupButton: UIButton!

var signupButtonStream: AnyCancellable?

override func viewDidLoad() {
    super.viewDidLoad()
    self.signupButtonStream = self.validatedCredentials
        .map { $0 != nil }
        .receive(on: RunLoop.main)
        .assign(to: \.isEnabled, on: signupButton)
}
----

* binding with models

* binding with notifications

* binding to RealityKit

binding to objects to send data to them

* binding to SwiftUI
** validating forms
** UX responsiveness - live updates to view properties
** handling error within property update
** retry for remote service


[#patterns-testing]
== testing

test strategies with combine

** testing streams/pipelines
** testing publishers
** testing subscribers

using PassthroughSubject and creative sinks