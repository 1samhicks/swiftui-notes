[#reference]
= Reference

reference preamble goes here...

[NOTE]
====
This is intended to extend Apple's documentation, not replace it.

* The documentation associated with beta2 is better than beta1, but still fairly anemic.

things to potentially include for each segment

* narrative description of what the function does
** notes on why you might want to use it, or where you may see it
** xref back to patterns document where functions are being used
* marble/railroad diagram explaining what the transformation/operator does
* sample code showing it being used and/or tested
====

[#reference-publishers]
== Publishers

//NOTE(heckj) make xref link back to coreconcepts:publishers

[#reference-just]
=== Just

__Summary__::

`just` provides a single result and then terminates.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/just[`Just`]

__Usage__::

n/a

__Details__::

* Just -> `<SomeType>`, `<Never>`
** often used in error handling

[#reference-future]
=== Future

__Summary__::

A future is initialized with a closure that eventually resolves to a value.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/future[Future].

__Usage__::

n/a

__Details__::

* you provide a closure that converts a callback/function of your own choosing into a https://developer.apple.com/documentation/combine/future/promise[Promise].
* in creating a Future publisher, you need to handle the logic of when you generate the relevant `Result<Output, Error>` with the asynchronous calls.

[#reference-published]
=== Published

__Summary__::

A property wrapper that adds a Combine publisher to any property

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/published[Published]

__Usage__::

n/a

__Details__::

Output type is inferred from the property being wrapped.

publisher -> `<SomeType>`, `<Never>`

* extracts a property from an object and returns it
** ex: `.publisher(for: \.name)`

[#reference-empty]
=== Publishers.Empty

__Summary__::

`empty` never publishes any values, and optionally finishes immediately.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/empty[`Publishers.Empty`]

__Usage__::

* <<patterns.adoc#patterns-oneshot-error-handling>> shows an example of using `catch` to handle errors with a one-shot publisher.
* <<patterns.adoc#patterns-continual-error-handling>> shows an example of using `catch` with `flatMap` to handle errors with a continual publisher.

__Details__::

* Empty -> `<SomeType>`, `<Error>`
** `Empty(completeImmediately: false)`

[#reference-fail]
=== Publishers.Fail

__Summary__::

`fail` immediately terminates publishing with the specified failure.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/fail[`Publishers.Fail`]

__Usage__::

n/a

__Details__::

n/a

[#reference-once]
=== Publishers.Once

__Summary__::

Generates an output to each subscriber exactly once then finishes or fails immediately.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/once[`Publishers.Once`]

__Usage__::

n/a

__Details__::

n/a

[#reference-optional]
=== Publishers.Optional

__Summary__::

generates a value exactly once for each subscriber, if the optional has a value

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/optional[`Publishers.Optional`]

__Usage__::

n/a

__Details__::

n/a

[#reference-sequence]
=== Publishers.Sequence

__Summary__::

Publishes a provided sequence of elements.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/sequence[`Publishers.Sequence`]

__Usage__::

n/a

__Details__::

n/a


[#reference-deferred]
=== Publishers.Deferred

__Summary__::

Publisher waits for a subscriber before running the provided closure to create values for the subscriber.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/deferred[`Publishers.Deferred`]

__Usage__::

n/a

__Details__::

n/a

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-swiftUI]
=== SwiftUI

* @ObjectBinding (swiftUI)
* BindableObject

* often linked with method `didChange` to publish changes to model objects
** `@ObjectBinding var model: MyModel`

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-foundation]
=== Foundation

* https://developer.apple.com/documentation/foundation/notificationcenter[`NotificationCenter`] https://developer.apple.com/documentation/foundation/notificationcenter/3329353-publisher[`.publisher`]

* https://developer.apple.com/documentation/foundation/timer[`Timer`] https://developer.apple.com/documentation/foundation/notificationcenter/3329353-publisher[`.publish`] and https://developer.apple.com/documentation/foundation/timer/timerpublisher[`Timer.TimerPublisher`]

** * https://developer.apple.com/documentation/foundation/timer/timerpublisher[TimerPublisher]

[#reference-dataTaskPublisher]
=== URLSession.dataTaskPublisher

__Summary__::

Foundation's https://developer.apple.com/documentation/foundation/urlsession[`URLSession`] has a publisher specifically for requesting data from URLs: dataTaskPublisher

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/foundation/urlsession/datataskpublisher[`URLSession.DataTaskPublisher`]

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-decode>>
* <<patterns.adoc#patterns-oneshot-error-handling>>
* <<patterns.adoc#patterns-retry>>
* <<patterns.adoc#patterns-constrained-network>>

__Details__::

`dataTaskPublisher`, on URLSession, has two variants for creating a publisher.
The first takes an instance of https://developer.apple.com/documentation/foundation/url[URL], the second https://developer.apple.com/documentation/foundation/urlrequest[URLRequest].
The data returned from the publisher is a tuple of `(data: Data, response: https://developer.apple.com/documentation/foundation/urlResponse[URLResponse])`.

[source,swift]
----
let request = URLRequest(url: regularURL)
return URLSession.shared.dataTaskPublisher(for: request)
----

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-realitykit]
=== RealityKit

* https://developer.apple.com/documentation/realitykit[`RealityKit`] https://developer.apple.com/documentation/realitykit/scene[`.Scene`] https://developer.apple.com/documentation/realitykit/scene/3254685-publisher[`.publisher()`]

Scene Publisher (from https://developer.apple.com/documentation/realitykit[RealityKit])

* https://developer.apple.com/documentation/realitykit/scene/publisher[Scene.Publisher]
** https://developer.apple.com/documentation/realitykit/sceneevents[SceneEvents]
** https://developer.apple.com/documentation/realitykit/animationevents[AnimationEvents]
** https://developer.apple.com/documentation/realitykit/audioevents[AudioEvents]
** https://developer.apple.com/documentation/realitykit/collisionevents[CollisionEvents]

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators]
== Operators

//NOTE(heckj) make xref link back to coreconcepts:operators

[#reference-operators-mapping]
=== Mapping elements

// NOTE(heckj): add xref link to reference section when written

[#reference-scan]
==== scan

* scan

[#reference-tryScan]
==== tryScan

* tryScan

[#reference-map]
==== map

__Summary__::

map is most commonly used to convert one data type into another along a pipeline.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/map

n/a

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-decode>>
* <<patterns.adoc#patterns-oneshot-error-handling>>
* <<patterns.adoc#patterns-retry>>

__Details__::

The map operator doesn't allow for any additional failures to be thrown, and doesn't transform the failure type.
If you want to throw an error within your closure, then use the <<#reference-tryMap>> operator.

map takes a single closure where you provide the logic for the map operation.

For example, the <<#reference-dataTaskPublisher>> provides a tuple of `(data: Data, response: URLResponse)`` as its output.
You can use map to pass along the data, for example to use with <<#reference-decode>>.

[source, swift]
----
.map { $0.data } <1>
----

<1> the `$0` indicates to grab the first parameter passed in, which is a tuple of `data` and `response`.

In some cases, the closure may not be able to infer what data type you are returning, so you may need to provide a definition to help the compiler.
For example, if you have an object getting passed down that has a boolean property "isValid" on it, and you just want the boolean for your pipeline, you might set that up like:

[source, swift]
----
struct myStruct {
    isValid: bool = true
}
//
Just(myStruct())
.map { inValue -> Bool in <1>
  inValue.isValid <2>
}
----

<1> inValue is named as the parameter coming in, and the return type is being explicitly specified to `Bool`
<2> A single line is an implicit return, in this case it's pulling the `isValid` property off the struct and passing it down the pipeline.

[#reference-tryMap]
==== tryMap

__Summary__::

tryMap is effectively the similiar to <<#reference-map>>, except that it also allows you to provide a closure that throws additional errors if your conversion logic is unsuccessful.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/trymap

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-tryMap>>

__Details__::

tryMap is useful when you have more complex business logic around your map and you want to indicate that the data passed in is an error, possibly handling that error later in the pipeline.
If you are looking at tryMap to decode JSON, you may want to consider using the <<#reference-decode>> operator instead, which is set up for that common task.

[source, swift]
----
enum myFailure: Error {
    case notBigEnough
}

//
Just(5)
.tryMap {
  if inValue < 5 { <1>
      throw myFailure.notBigEnough <2>
  }
  return inValue <3>
}
----

<1> You can specify whatever logic is relevant to your use case within tryMap
<2> and throw an error, although throwing an Error isn't required.
<3> If the error condition doesn't occur, you do need to pass down data for any further subscribers.


[#reference-flatMap]
==== flatpMap

* flatMap

** collapses nil values out of a stream
** used with error recovery or async operations that might fail (ex: Future)
** requires Failure to be `<Never>`

[#reference-setFailureType]
==== setFailureType

* setFailureType

[#reference-operators-filtering]
=== Filtering elements

[#reference-compactMap]
==== compactMap

* compactMap
** republishes all non-nil results of calling a closure with each received element.
** there's a variant `tryCompactMap` for use with a provided error-throwing closure.

[#reference-tryCompactMap]
==== tryCompactMap

* tryCompactMap

[#reference-filter]
==== filter

* filter

** requires Failure to be `<Never>`
** takes a closure where you can specify how/what gets filtered
** there's a variant `tryFilter`for use with a provided error-throwing closure.

[#reference-tryFilter]
==== tryFilter

* tryFilter

[#reference-removeDuplicates]
==== removeDuplicates

* removeDuplicates

** `.removeDuplicates()`
** remembers what was previously sent in the stream, and only passes forward new values
** there's a variant `tryRemoveDuplicates` for use with a provided error-throwing closure.

[#reference-tryRemoveDuplicates]
==== tryRemoveDuplicates

* tryRemoveDuplicates

[#reference-replaceEmpty]
==== replaceEmpty

* replaceEmpty
** requires Failure to be `<Never>`

[#reference-replaceError]
==== replaceError

* replaceError
** requires Failure to be `<Never>`

[#reference-replaceNil]
==== replaceNil

* replaceNil
** requires Failure to be `<Never>`
** Replaces nil elements in the stream with the proviced element.

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-reducing]
=== Reducing elements

[#reference-collect]
==== collect
* collect
** multiple variants
*** buffers items
*** `collect()` Collects all received elements, and emits a single array of the collection when the upstream publisher finishes.
*** `collect(Int)` collects N elements and emits as an array
*** `collect(.byTime)` or `collect(.byTimeOrCount)`

[#reference-collectByCount]
==== collectByCount

* collectByCount

[#reference-collectByTime]
==== collectByTime

* collectByTime

[#reference-ignoreOutput]
==== ignoreOutput

* ignoreOutput

[#reference-reduce]
==== reduce

* reduce
** A publisher that applies a closure to all received elements and produces an accumulated value when the upstream publisher finishes.
** requires Failure to be `<Never>`
** there's a varient `tryReduce` for use with a provided error-throwing closure.


[#reference-tryReduce]
==== tryReduce

* tryReduce

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-mathematical]
=== Mathematic opertions on elements

[#reference-max]
==== max

* max
** Available when Output conforms to Comparable.
** Publishes the maximum value received from the upstream publisher, after it finishes.

[#reference-min]
==== min
** Publishes the minimum value received from the upstream publisher, after it finishes.
** Available when Output conforms to Comparable.


[#reference-comparison]
==== comparison

* comparison
** republishes items from another publisher only if each new item is in increasing order from the previously-published item.
** there's a variant `tryComparson` which fails if the ordering logic throws an error

[#reference-tryComparison]
==== tryComparison

* tryComparison

[#reference-count]
==== count

* count
** publishes the number of items received from the upstream publisher

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-criteria]
=== Applying matching criteria to elements

[#reference-allSatisfy]
==== allSatisfy

* allSatisfy
** Publishes a single Boolean value that indicates whether all received elements pass a given predicate.
** there's a variant `tryAllSatisfy` when the predicate can throw errors

[#reference-tryAllSatisfy]
==== tryAllSatisfy

* tryAllSatisfy

[#reference-contains]
==== contains

* contains
** emits a Boolean value when a specified element is received from its upstream publisher.
** variant `containsWhere` when a provided predicate is satisfied
** variant `tryContainsWhere` when a provided predicate is satisfied but could throw errors

[#reference-containsWhere]
==== containsWhere

* containsWhere

[#reference-tryContainsWhere]
==== tryContainsWhere

* tryContainsWhere

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-sequence]
=== Applying sequence operations to elements

[#reference-first]
==== first

* first
** requires Failure to be `<Never>`
** publishes the first element to satisfy a provided predicate

[#reference-firstWhere]
==== firstWhere

* firstWhere

[#reference-tryFirstWhere]
==== tryFirstWhere

* tryFirstWhere

[#reference-last]
==== last

* last
** requires Failure to be `<Never>`
** publishes the last element to satisfy a provided predicate

[#reference-lastWhere]
==== lastWhere
* lastWhere

[#reference-tryLastWhere]
==== tryLastWhere

* tryLastWhere

[#reference-dropUntilOutput]
==== dropUntilOutput

* dropUntilOutput

[#reference-dropWhile]
==== dropWhile

* dropWhile

[#reference-tryDropWhile]
==== tryDropWhile

* tryDropWhile

[#reference-concatenate]
==== concatenate

* concatenate

[#reference-drop]
==== drop
* drop
** multiple variants
** requires Failure to be `<Never>`
** Ignores elements from the upstream publisher until it receives an element from a second publisher.
** or `drop(while: {})`

[#reference-prefixUntilOutput]
==== prefixUntilOutput

* prefixUntilOutput
** Republishes elements until another publisher emits an element.
** requires Failure to be `<Never>`

[#reference-prefixWhile]
==== prefixWhile

* prefixWhile
** Republishes elements until another publisher emits an element.
** requires Failure to be `<Never>`

[#reference-tryPrefixWhile]
==== tryPrefixWhile

* tryPrefixWhile
** Republishes elements until another publisher emits an element.
** requires Failure to be `<Never>`

[#reference-output]
==== output

* output

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-combinepublishers]
=== Combining elements from multiple publishers

[#reference-combineLatest]
==== combineLatest

* combineLatest
** brings inputs from 2 (or more) streams together
** you provide a closure that gets the values and chooses what to publish

[#reference-tryCombineLatest]
==== tryCombineLatest

* tryCombineLatest

[#reference-merge]
==== merge

* merge

** Combines elements from this publisher with those from another publisher of the same type, delivering an interleaved sequence of elements.
** requires Failure to be `<Never>`
** multiple variants that will merge between 2 and 8 different streams

[#reference-zip]
==== zip

* zip
** Combine elements from another publisher and deliver pairs of elements as tuples.
** requires Failure to be `<Never>`

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-handlingErrors]
=== Handling errors

See <<patterns.adoc#patterns-general-error-handling>> for more detail on how you can design error handling.

[#reference-assertNoFailure]
==== assertNoFailure

* assertNoFailure
** Raises a fatal error when its upstream publisher fails, and otherwise republishes all received input.

[#reference-catch]
==== catch

__Summary__::

The operator `catch` handles errors (completion messages of type `.failure`) from an upstream publisher by replacing the failed publisher with another publisher.
The operator also transforms the Failure type to `<Never>`.

__Constraints on connected publisher__::

* __none__

__icon:apple[] Documentation reference__:: https://developer.apple.com/documentation/combine/publishers/catch[`Publishers.Catch`]

__Usage__::

* <<patterns.adoc#patterns-oneshot-error-handling>> shows an example of using `catch` to handle errors with a one-shot publisher.
* <<patterns.adoc#patterns-continual-error-handling>> shows an example of using `catch` with `flatMap` to handle errors with a continual publisher.

__Details__::

Once catch receives a `.failure` completion, it won't send any further incoming values from the original upstream publisher.
You can also view catch as a switch that only toggles in one direction: to using a new publisher that you define, but only when the original publisher to which it is subscribed sends an error.

This can be illustrated with the following code snippet:

[source, swift]
----
enum testFailureCondition: Error {
    case invalidServerResponse
}

let simplePublisher = PassthroughSubject<String, Error>()

let _ = simplePublisher
    .catch { err in
        // must return a Publisher
        return Just("replacement value")
    }
    .sink(receiveCompletion: { fini in
        print(".sink() received the completion:", String(describing: fini))
    }, receiveValue: { stringValue in
        print(".sink() received \(stringValue)")
    })

simplePublisher.send("oneValue")
simplePublisher.send("twoValue")
simplePublisher.send(completion: Subscribers.Completion.failure(testFailureCondition.invalidServerResponse))
simplePublisher.send("redValue")
simplePublisher.send("blueValue")
simplePublisher.send(completion: .finished)
----

In this example, we are using a `PassthroughSubject` so that we can control when and what gets sent from the publisher.
In the above code, we are sending two good values, then a failure, then attempting to send two more good values.
The values you would see printed from our `.sink()` closures are:

[source]
----
.sink() received oneValue
.sink() received twoValue
.sink() received replacement value
.sink() received the completion: finished
----

When the failure was sent through the pipeline, catch intercepts it and returns "replacement value" as expected.
The replacement publisher it used (`Just`) sends a single value and then sends a completion.
If we want the pipeline to remain active, we need to change how we handle the errors.

[#reference-retry]
==== retry

* retry
** multiple variants - once or by a provided count
** forces Failure type of Never on output

[#reference-mapError]
==== mapError

* mapError
** Converts any failure from the upstream publisher into a new error.

[#reference-operators-adaptingTypes]
=== Adapting publisher types

[#reference-switchToLatest]
==== switchToLatest

* switchToLatest?

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-timing]
=== Controlling timing

[#reference-debounce]
==== debounce

* debounce
** `.debounce(for: 0.5, scheduler: RunLoop.main)`
** collapses multiple values within a specified time window into a single value
** often used with `.removeDuplicates()`

[#reference-delay]
==== delay

* delay
** Delays delivery of all output to the downstream receiver by a specified amount of time on a particular scheduler.
** requires Failure to be `<Never>`

[#reference-measureInterval]
==== measureInterval

* measureInterval
** Measures and emits the time interval between events received from an upstream publisher.
** requires Failure to be `<Never>`

[#reference-throttle]
==== throttle

* throttle
** Publishes either the most-recent or first element published by the upstream publisher in the specified time interval.
** requires Failure to be `<Never>`

[#reference-timeout]
==== timeout

* timeout
** Terminates publishing if the upstream publisher exceeds the specified time interval without producing an element.
** requires Failure to be `<Never>`

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-coding]
=== Encoding and decoding

[#reference-encode]
==== encode

__Summary__::

Encode converts the output from upstream Encodable object using a specified TopLevelEncoder. For example, use JSONEncoder or PropertyListEncoder..

__Constraints on connected publisher__::

* Available when Output conforms to Encodable.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/encode

__Usage__::

* unit tests illustrating using encode and decode: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EncodeDecodeTests.swift[`UsingCombineTests/EncodeDecodeTests.swift`]


__Details__::

The encode operator takes a single parameters:

* `encoder` an instance of an object conforming to https://developer.apple.com/documentation/combine/toplevelencoder[TopLevelEncoder], frequently an instance of https://developer.apple.com/documentation/foundation/jsonencoder[JSONEncoder]() or https://developer.apple.com/documentation/foundation/propertylistencoder[PropertyListEncoder]().

[source, swift]
----
fileprivate struct PostmanEchoTimeStampCheckResponse: Codable {
    let valid: Bool
}

let dataProvider = PassthroughSubject<PostmanEchoTimeStampCheckResponse, Never>()
    .encode(encoder: JSONEncoder())
    .sink { data in
        print(".sink() data received \(data)")
        let stringRepresentation = String(data: data, encoding: .utf8)
        print(stringRepresentation)
    })
----

Like the <<#reference-decode>> operator, the encode process can also fail and throw an error, so it returns a failure type of Error.
With the compiler forcing type matching, the usual error condition is if you flow an optional value into the pipeline.

[#reference-decode]
==== decode

__Summary__::

A very common operation is to want to use decode (or <<#reference-encode>> data in a pipline, so Combine provides an operator specifically suited to that task.

__Constraints on connected publisher__::

* Available when Output conforms to Decodable.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/decode

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-decode>>
* <<patterns.adoc#patterns-dataTaskPublisher-tryMap>>
* <<patterns.adoc#patterns-oneshot-error-handling>>
* <<patterns.adoc#patterns-retry>>
* unit tests illustrating using encode and decode: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EncodeDecodeTests.swift[`UsingCombineTests/EncodeDecodeTests.swift`]


__Details__::

The decode operator takes two parameters:

* `type` which is typically a reference to a struct you've defined
* `decoder` an instance of an object conforming to https://developer.apple.com/documentation/combine/topleveldecoder[TopLevelDecoder], frequently an instance of https://developer.apple.com/documentation/foundation/jsondecoder[JSONDecoder]() or https://developer.apple.com/documentation/foundation/propertylistdecoder[PropertyListDecoder]().

Since decoding can fail, the operator will also return a failure type of Error.
The data type returned by the operator is defined by the type you provided to decode.

[source, swift]
----
let testUrlString = "https://postman-echo.com/time/valid?timestamp=2016-10-10"
// checks the validity of a timestamp - this one should return {"valid":true}
// matching the data structure returned from https://postman-echo.com/time/valid
fileprivate struct PostmanEchoTimeStampCheckResponse: Decodable, Hashable {
    let valid: Bool
}

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: URL(string: testUrlString)!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .map { $0.data }
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder())
----

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-multipleSubscribers]
=== Working with multiple subscribers

[#reference-multicast]
==== multicast

* multicast

[#reference-operators-debugging]
=== Debugging

[#reference-breakpoint]
==== breakpoint

* breakpoint
** Raises a debugger signal when a provided closure needs to stop the process in the debugger.

[#reference-breakpointOnError]
==== breakpointOnError

* breakpointOnError
** Raises a debugger signal upon receiving a failure.

[#reference-handleEvents]
==== handleEvents

* handleEvents

[#reference-print]
==== print

* print
** Prints log messages for all publishing events.
** requires Failure to be `<Never>`

// force a page break - in HTML rendering is just a <HR>
<<<
'''

=== Scheduler and Thread handling operators

[#reference-receive]
==== receive

__Summary__::

Receive defines the scheduler on which to receive elememts from the publisher.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publisher/3204743-receive[`receive`]

__Usage__::

* <<patterns.adoc#patterns-assign-subscriber>> shows an example of using assign to set an a boolean property on a UI element.
* unit tests illustrating using an assign subscriber in a pipeline from a dataTaskPublisher with subscribe and receive: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift[`UsingCombineTests/SubscribeReceiveAssignTests.swift`]

__Details__::

Receive takes a single required parameter (`on:`) which accepts a scheduler, and an optional parameter (`optional:`) which can accept SchedulerOptions.
https://developer.apple.com/documentation/combine/scheduler[Scheduler] is a protocol in Combine, with the conforming types that are commonly used of https://developer.apple.com/documentation/foundation/runloop[RunLoop], https://developer.apple.com/documentation/dispatch/dispatchqueue[DispatchQueue] and https://developer.apple.com/documentation/foundation/operationqueue[OperationQueue].
Receive is frequently used with <<#reference-assign>> to make sure any following pipeline invocations happen on a specific thread, such as `RunLoop.main` when updating user interface objects.
Receive effects itself and any opertors chained after it, but not previous operators.
If you want to influence previously chained publishers (or operators) for where to run, use the <<#reference-subscribe>> operator.

[source, swift]
----
examplePublisher.receive(on: RunLoop.main)
----

Receive takes a single
[#reference-subscribe]
==== subscribe

__Summary__::

Subscribe defines the scheduler on which to run operators in a pipeline.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/anypublisher/3204260-subscribe[`subscribe`]


__Usage__::

* <<patterns.adoc#patterns-assign-subscriber>> shows an example of using assign to set an a boolean property on a UI element.
* unit tests illustrating using an assign subscriber in a pipeline from a dataTaskPublisher with subscribe and receive: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift[`UsingCombineTests/SubscribeReceiveAssignTests.swift`]

__Details__::

Subscribe assigns a scheduler to any preceding pipeline invocations, and is often used to invoke a publisher on a background thread or queue. When used in this fashion, it is often used in coordination with <<#reference-receive>> to transfer data to another thread (such as the main runloop) for following operators or the subscriber.

Subscribe takes a single required parameter (`on:`) which accepts a scheduler, and an optional parameter (`optional:`) which can accept SchedulerOptions.
https://developer.apple.com/documentation/combine/scheduler[Scheduler] is a protocol in Combine, with the conforming types that are commonly used of https://developer.apple.com/documentation/foundation/runloop[RunLoop], https://developer.apple.com/documentation/dispatch/dispatchqueue[DispatchQueue] and https://developer.apple.com/documentation/foundation/operationqueue[OperationQueue].

Subscribe effects itself and any opertors chained before it, but not following operators.
If you want to influence chained operators after subscribe for where to run, use the <<#reference-receive>> operator.
The most comon example of this is receiving on `RunLoop.main`, critical when updating user interface objects.

[source, swift]
----
networkDataPublisher
    .subscribe(on: backgroundQueue) <1>
    .receive(on: RunLoop.main) <2>
    .assign(to: \.text, on: yourLabel) <3>
----

<1> the `subscribe` call requests the publisher (and any pipeline invocations before this in a chain) be invoked on the backgroundQueue.
<2> the `receive` call transfers the data to the main runloop, suitable for updating user interface elements
<3> the `assign` call uses the <<#reference-assign>> subscriber to update the property `text` on a KVO compliant object, in this case `yourLabel`.

[NOTE]
====
When creating a DispatchQueue to use with Combine publishers on background threads, it is recommended that you use a regular serial queue rather than a concurrent queue https://forums.swift.org/t/runloop-main-or-dispatchqueue-main-when-using-combine-scheduler/26635/4[to allow Combine to adhere to its contracts].
That is - don't create the queue with `attributes: .concurrent`.
====

// force a page break - in HTML rendering is just a <HR>
<<<
'''

=== Type erasure operators

[#reference-eraseToAnyPublisher]
==== eraseToAnyPublisher

** when you chain operators together in swift, the object's type signature accumulates all the various types, and it gets ugly pretty quickly.
** eraseToAnyPublisher takes the signature and "erases" the type back to the common type of AnyPublisher
** this provides a cleaner type for external declarations (framework was created prior to Swift 5's opaque types)
** `.eraseToAnyPublisher()`
** often at the end of chains of operators, and cleans up the type signature of the property getting asigned to the chain of operators

[#reference-eraseToAnySubscriber]
==== eraseToAnySubscriber

[#reference-eraseToAnySubject]
==== eraseToAnySubject

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-subjects]
== Subjects

//xref to coreconcepts - subjects

[#reference-currentValueSubject]
=== currentValueSubject

* https://developer.apple.com/documentation/combine/currentvaluesubject[`CurrentValueSubject`]

[#reference-passthroughSubject]
=== PassthroughSubject

* https://developer.apple.com/documentation/combine/passthroughsubject[`PassthroughSubject`]

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-subscribers]
== Subscribers

For general information about subscribers and how they fit with publishers and operators, see <<coreconcepts.adoc#core-subscribers>>.

[#reference-assign]
=== assign

__Summary__::

Assign creates a subscriber used to update a property on a KVO compliant object.

__Constraints on connected publisher__::

* Failure type must be `<Never>`

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/subscribers/assign[`assign`]

__Usage__::

* <<patterns.adoc#patterns-assign-subscriber>> shows an example of using assign to set an a boolean property on a UI element.
* unit tests illustrating using an assign subscriber in a pipeline from a dataTaskPublisher with subscribe and receive: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift[`UsingCombineTests/SubscribeReceiveAssignTests.swift`]

__Details__::

Assign only handles data, and expects all errors or failures to be handled in the pipeline before it is invoked.
The return value from setting up assign can be cancelled, and is frequently used when disabling the pipeline, such as when a viewController is disabled or deallocated.
Assign is frequently used in conjunction with the <<#reference-receive>> operator to receive values on a specific scheduler, typically `RunLoop.main` when updating UI objects.

[source, swift]
----
examplePublisher
    .receive(on: RunLoop.main) <2>
    .assign(to: \.text, on: yourLabel) <3>
----

[#reference-sink]
=== sink

__Summary__::

Sink creates an all-purpose subscriber.
At a minimum, you provide a closure to receive values, and optionally a closure that receives completions.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/subscribers/sink[`sink`]

__Usage__::

* <<patterns.adoc#patterns-sink-subscriber>> shows an example of creating a sink that receives both completion messages as well as data from the publisher.
* unit tests illustrating a sink subscriber and how it works: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SinkSubscriberTests.swift[`UsingCombineTests/SinkSubscriberTests.swift`]

__Details__::

The simplest form of `.sink()` takes a single closure - by default this closure receives data (if provided by the attached publisher).

[source, swift]
----
let examplePublisher = Just(5)

let _ = examplePublisher.sink { value in
    print(".sink() received \(String(describing: value))")
}
----

The closure you provide is invoked for every update that the publisher passes down, up until the completion.
Be aware that the single closure form may be called repeatedly.
How often it is called depends on the pipeline to which it is subscribing.

If you don't also include a closure to get the completion, you will not receive any information about failures.
If an error or failure occurs and is handed down from the publisher the single closure form will not be called.

If you are creating a subscriber and want to receive failures, or see the completion messages at the end of pipeline, create a sink with two closures.
The more complete sink has the two closures named `receiveCompletion` and `receiveValue`:

[source, swift]
----
let examplePublisher = Just(5)

let _ = examplePublisher.sink(receiveCompletion: { err in
    print(".sink() received the completion", String(describing: err))
}, receiveValue: { value in
    print(".sink() received \(String(describing: value))")
})
----

The type that is passed into receiveCompletion is the enum https://developer.apple.com/documentation/combine/subscribers/completion[`Subscribers.Completion`].
The completion `.failure` incudes an Error wrapped within it, providing access to the underlying cause of the failure.
To get to the error within the `.failure` completion, `switch` on the returned completion to determine if it is `.finished` or `.failure`, and then pull out the error.

When you chain a `.sink` subscriber onto a publisher (or pipeline), the result is cancellable.
At any time before the publisher sends a completion, the subscriber can send a cancellation and invalidate the pipeline.
After a cancel is sent, no further values will be received by either closure in the sink.

[source,swift]
----
let simplePublisher = PassthroughSubject<String, Error>()
let cancellablePipeline = simplePublisher.sink { data in
  // do what you need with the data...
}

cancellablePublisher.cancel() // this invalidates the pipeline, no further data will be received by the sink
----

