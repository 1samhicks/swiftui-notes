[#reference]
= Reference

reference preamble goes here...

[NOTE]
====
This is intended to extend Apple's documentation, not replace it.

* The documentation associated with beta2 is better than beta1, but still fairly anemic.

things to potentially include for each segment

* narrative description of what the function does
** notes on why you might want to use it, or where you may see it
** xref back to patterns document where functions are being used
* marble/railroad diagram explaining what the transformation/operator does
* sample code showing it being used and/or tested
====

[#reference-publishers]
== Publishers

//NOTE(heckj) make xref link back to coreconcepts:publishers

[#reference-just]
=== Just

__Summary__::

`Just` provides a single result and then terminates, providing a publisher with a failure type of `<Never>`

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/just[`Just`]

__Usage__::

* <<patterns.adoc#patterns-oneshot-error-handling>>
* <<patterns.adoc#patterns-continual-error-handling>>
* <<patterns.adoc#patterns-update-interface-network-request>>

__Details__::

Often used within a closure to <<#reference-flatmap>> in error handling, it can see a one-shot pipeline for use in error handling of continuous values.

[#reference-future]
=== Future

__Summary__::

A future is initialized with a closure that eventually resolves to a value.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/future[Future].

__Usage__::

n/a

__Details__::

* you provide a closure that converts a callback/function of your own choosing into a https://developer.apple.com/documentation/combine/future/promise[Promise].
* in creating a Future publisher, you need to handle the logic of when you generate the relevant `Result<Output, Error>` with the asynchronous calls.

[#reference-published]
=== Published

__Summary__::

A property wrapper that adds a Combine publisher to any property

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/published[Published]

__Usage__::

* <<patterns.adoc#patterns-update-interface-network-request>>
* unit tests illustrating using Published: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift[`UsingCombineTests/PublisherTests.swift`]

__Details__::

Published is part of combine, but allows you to wrap an property, enabling you to get a publisher that triggers data updates whenever the property is changed.
The publisher's output type is inferred from the type of the property, and the error type of the provided publisher is <Never>.

There are two examples of using Published in <<patterns.adoc#patterns-update-interface-network-request>>.

A smaller examples of how it can be used:

[source, swift]
----
@Published var username: String = "" <1>

$username <2>
    .sink { someString in
        print("value of username updated to: ", someString)
    }

$username <3>
    .assign(\.text, on: myLabel)

@Published private var githubUserData: [GithubAPIUser] = [] <4>
----

<1> `@Published` wraps the property, username, and will generate events whenever the property is changed.
If there is a subscriber at initialization time, the subscriber will also receive the initial value being set.
The publisher for the property is available at the same scope, and with the same permissions, as the property itself.
<2> The publisher is accessible as `$username`, of type `Published<String>.publisher`.
<3> A Published property can have more than one subscriber pipeline triggering from it.
<4> If you're publishing your own type, you may find it convenient to publish an array of that type as the property, even if you only reference a single value.
This allows you represent an "Empty" result that is still a concrete result within combine pipelines, as <<#reference-assign>> and <<#reference-sink>> subscribers will only trigger updates on non-nil values.

If the publisher generated from `@Published` receives a cancellation from any subscriber, it is expected to, and will cease, reporting property changes.
Because of this expectation, it is common to arrange pipelines from these publishers that have an error type of `<Never>` and do all error handling within the pipelines.
For example, if a <<#reference-sink>> subscriber is set up to capture errors from a pipeline originating from a @Published property, when the error is received, the sink will send a `cancel` message, causing the publisher to cease generating any updates on change.
This is illustrated in the test `testPublishedSinkWithError` at https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift[`UsingCombineTests/PublisherTests.swift`]

Additional examples of how to arrange error handling for a continous publisher like `@Published` can be found at  <<patterns.adoc#patterns-continual-error-handling>>.

[WARNING]
====
As of the beta3 release of Combine with the updated operating systems, Published doesn't always trigger updates when a struct is the holding the @Published variable, but it works within a class instance.
The unit tests at https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift[`UsingCombineTests/PublisherTests.swift`] illustrate this with the tests:
* `testPublishedOnStructWithChange`
* `testPublishedOnClassWithChange`
====

[#reference-empty]
=== Publishers.Empty

__Summary__::

`empty` never publishes any values, and optionally finishes immediately.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/empty[`Publishers.Empty`]

__Usage__::

* <<patterns.adoc#patterns-oneshot-error-handling>> shows an example of using `catch` to handle errors with a one-shot publisher.
* <<patterns.adoc#patterns-continual-error-handling>> shows an example of using `catch` with `flatMap` to handle errors with a continual publisher.
* <<patterns.adoc#patterns-update-interface-network-request>>
* The unit tests at https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EmptyPublisherTests.swift[`UsingCombineTests/EmptyPublisherTests.swift`]

__Details__::

Empty is useful in error handling scenarios where with publishers where the value is an optional, or where you want to resolve an error by simply not sending anything.
Empty can be invoked to be a publisher of any output and failure type combination.

Empty is most commonly used where you need to return a publisher, but don't want to propogate any values (a possible error handling scenario).
If you want a publisher that provides a single value, then look at <<#reference-just>>, <<#reference-once>>, or <<#reference-optional>> publishers as alternatives.

When subscribed to, an instance of the Empty publisher will not return any values (or errors) and will immediately return a finished completion message to the subscriber.

An example of using Empty
[source, swift]
----
let myEmptyPublisher = Publishers.Empty<String, Never>() <1>
----
<1> Because the types are not be able to be inferred, expect to always define the types you want to return within the declaration.


[#reference-fail]
=== Publishers.Fail

__Summary__::

`fail` immediately terminates publishing with the specified failure.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/fail[`Publishers.Fail`]

__Usage__::

n/a

__Details__::

n/a

[#reference-once]
=== Publishers.Once

__Summary__::

Generates an output to each subscriber exactly once then finishes or fails immediately.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/once[`Once`]

__Usage__::

TBD

__Details__::

Used similiarly to <<#reference-just>>, it provides a value and then completes.
It is often used with flatMap when you want to flow have flatMap return a publisher that returns a publisher with an error type.
Where <<#reference-just>> returns a failure type of `<Never>`, `once` allows for a failure type of `<Error>`.

[#reference-optional]
=== Publishers.Optional

__Summary__::

generates a value exactly once for each subscriber, if the optional has a value

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/optional[`Publishers.Optional`]

__Usage__::

n/a

__Details__::

n/a

[#reference-sequence]
=== Publishers.Sequence

__Summary__::

Publishes a provided sequence of elements.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/sequence[`Publishers.Sequence`]

__Usage__::

n/a

__Details__::

n/a


[#reference-deferred]
=== Publishers.Deferred

__Summary__::

Publisher waits for a subscriber before running the provided closure to create values for the subscriber.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/deferred[`Publishers.Deferred`]

__Usage__::

n/a

__Details__::

n/a

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-swiftUI]
=== SwiftUI

* @ObjectBinding (swiftUI)
* BindableObject

* often linked with method `didChange` to publish changes to model objects
** `@ObjectBinding var model: MyModel`

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-foundation]
=== Foundation

* https://developer.apple.com/documentation/foundation/notificationcenter[`NotificationCenter`] https://developer.apple.com/documentation/foundation/notificationcenter/3329353-publisher[`.publisher`]

* https://developer.apple.com/documentation/foundation/timer[`Timer`] https://developer.apple.com/documentation/foundation/notificationcenter/3329353-publisher[`.publish`] and https://developer.apple.com/documentation/foundation/timer/timerpublisher[`Timer.TimerPublisher`]

** * https://developer.apple.com/documentation/foundation/timer/timerpublisher[TimerPublisher]

[#reference-kvo-publisher]
=== .publisher on KVO instance

__Summary__::

Foundation added the ability to get a publisher on any Object that can be watched with Key Value Observing.

__icon:apple[] docs__:: __???__

[NOTE]
====
As of beta3, I was unable to find the documentation on the extension of NSObject.
In the generated swift declaration file, it's listed as an extension on NSObject - a struct named `KeyValueObservingPublisher`
====

__Usage__::

* The unit tests at https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/PublisherTests.swift[`UsingCombineTests/PublisherTests.swift`]

__Details__::

Any Key Value Observing instance can produce a publisher.
To create this publisher, you call the function `publisher` on the object, providing it with a single (required) KeyPath value.

For example:

[source, swift]
----
private final class KVOAbleNSObject: NSObject {
    @objc dynamic var intValue: Int = 0
    @objc dynamic var boolValue: Bool = false
}

let foo = KVOAbleNSObject()

let _ = foo.publisher(for: \.intValue)
    .sink { someValue in
        print("value updated to: >>\(someValue)<<")
    }
----

[NOTE]
====
KVO publisher access implies that with MacOS 10.15 release or IOS 13, most of Appkit and UIKit interface instances will be accessible as publishers.
Relying on the interface element's state to trigger updates into pipelines can lead to your state being very tightly bound to the interface elements, rather than your model.
You may be better served by explicitly creating your own state to react to from a <<#reference-published>> property wrapper.
====

[#reference-datataskpublisher]
=== URLSession.dataTaskPublisher

__Summary__::

Foundation's https://developer.apple.com/documentation/foundation/urlsession[`URLSession`] has a publisher specifically for requesting data from URLs: dataTaskPublisher

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/foundation/urlsession/datataskpublisher[`URLSession.DataTaskPublisher`]

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-decode>>
* <<patterns.adoc#patterns-oneshot-error-handling>>
* <<patterns.adoc#patterns-retry>>
* <<patterns.adoc#patterns-constrained-network>>
* <<patterns.adoc#patterns-update-interface-network-request>>

__Details__::

`dataTaskPublisher`, on URLSession, has two variants for creating a publisher.
The first takes an instance of https://developer.apple.com/documentation/foundation/url[URL], the second https://developer.apple.com/documentation/foundation/urlrequest[URLRequest].
The data returned from the publisher is a tuple of `(data: Data, response: https://developer.apple.com/documentation/foundation/urlResponse[URLResponse])`.

[source,swift]
----
let request = URLRequest(url: regularURL)
return URLSession.shared.dataTaskPublisher(for: request)
----

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-realitykit]
=== RealityKit

* https://developer.apple.com/documentation/realitykit[`RealityKit`] https://developer.apple.com/documentation/realitykit/scene[`.Scene`] https://developer.apple.com/documentation/realitykit/scene/3254685-publisher[`.publisher()`]

Scene Publisher (from https://developer.apple.com/documentation/realitykit[RealityKit])

* https://developer.apple.com/documentation/realitykit/scene/publisher[Scene.Publisher]
** https://developer.apple.com/documentation/realitykit/sceneevents[SceneEvents]
** https://developer.apple.com/documentation/realitykit/animationevents[AnimationEvents]
** https://developer.apple.com/documentation/realitykit/audioevents[AudioEvents]
** https://developer.apple.com/documentation/realitykit/collisionevents[CollisionEvents]

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators]
== Operators

//NOTE(heckj) make xref link back to coreconcepts:operators

[#reference-operators-mapping]
=== Mapping elements

// NOTE(heckj): add xref link to reference section when written

[#reference-scan]
==== scan

* scan

[#reference-tryScan]
==== tryScan

* tryScan

[#reference-map]
==== map

__Summary__::

map is most commonly used to convert one data type into another along a pipeline.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/map

n/a

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-decode>>
* <<patterns.adoc#patterns-oneshot-error-handling>>
* <<patterns.adoc#patterns-retry>>
* <<patterns.adoc#patterns-update-interface-network-request>>
* unit tests illustrating using map with dataTaskPublisher: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift[`UsingCombineTests/DataTaskPublisherTests.swift`]


__Details__::

The map operator doesn't allow for any additional failures to be thrown, and doesn't transform the failure type.
If you want to throw an error within your closure, then use the <<#reference-tryMap>> operator.

map takes a single closure where you provide the logic for the map operation.

For example, the <<#reference-datataskpublisher>> provides a tuple of `(data: Data, response: URLResponse)`` as its output.
You can use map to pass along the data, for example to use with <<#reference-decode>>.

[source, swift]
----
.map { $0.data } <1>
----

<1> the `$0` indicates to grab the first parameter passed in, which is a tuple of `data` and `response`.

In some cases, the closure may not be able to infer what data type you are returning, so you may need to provide a definition to help the compiler.
For example, if you have an object getting passed down that has a boolean property "isValid" on it, and you just want the boolean for your pipeline, you might set that up like:

[source, swift]
----
struct myStruct {
    isValid: bool = true
}
//
Just(myStruct())
.map { inValue -> Bool in <1>
  inValue.isValid <2>
}
----

<1> inValue is named as the parameter coming in, and the return type is being explicitly specified to `Bool`
<2> A single line is an implicit return, in this case it's pulling the `isValid` property off the struct and passing it down the pipeline.

[#reference-tryMap]
==== tryMap

__Summary__::

tryMap is effectively the similiar to <<#reference-map>>, except that it also allows you to provide a closure that throws additional errors if your conversion logic is unsuccessful.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/trymap

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-tryMap>>
* unit tests illustrating using tryMap with dataTaskPublisher: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift[`UsingCombineTests/DataTaskPublisherTests.swift`]

__Details__::

tryMap is useful when you have more complex business logic around your map and you want to indicate that the data passed in is an error, possibly handling that error later in the pipeline.
If you are looking at tryMap to decode JSON, you may want to consider using the <<#reference-decode>> operator instead, which is set up for that common task.

[source, swift]
----
enum myFailure: Error {
    case notBigEnough
}

//
Just(5)
.tryMap {
  if inValue < 5 { <1>
      throw myFailure.notBigEnough <2>
  }
  return inValue <3>
}
----

<1> You can specify whatever logic is relevant to your use case within tryMap
<2> and throw an error, although throwing an Error isn't required.
<3> If the error condition doesn't occur, you do need to pass down data for any further subscribers.

[#reference-flatmap]
==== flatMap

__Summary__::

Used with error recovery or async operations that might fail (ex: Future), flatMap will replace any incoming values with another publisher.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/flatmap[`flatMap`]

__Usage__::

* <<patterns.adoc#patterns-continual-error-handling>>
* unit tests illustrating flatMap: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SwitchAndFlatMapPublisherTests.swift[`UsingCombineTests/SwitchAndFlatMapPublisherTests.swift`]

__Details__::

Most typically used in error handling scenarios, flatMap takes a closure that allows you to read the incoming data value, and provide a publisher that returns a value to the pipeline.

In error handling, this is most frequently used to take the incoming value and create a one-shot pipeline that does some potentially failing operation, and then handling the error condition with a <<#reference-catch>> operator.

A diagram version of this pipeline construct might be:

[source]
----
     one-shot-publisher(value) -> catch ( fallback )      // <- one-shot pipeline
                          ^                        \
                          |                         \
publisher -> flatMap -> ( +                           +  ) -> subscriber
----

In swift, this looks like:

[source, swift]
----
.flatMap { data in
    return Just(data)
    .decode(YourType.self, JSONDecoder())
    .catch {
        return Just(YourType.placeholder)
    }
}
----

[#reference-setFailureType]
==== setFailureType

* setFailureType

[#reference-operators-filtering]
=== Filtering elements

[#reference-compactMap]
==== compactMap

* compactMap
** republishes all non-nil results of calling a closure with each received element.
** there's a variant `tryCompactMap` for use with a provided error-throwing closure.

[#reference-tryCompactMap]
==== tryCompactMap

* tryCompactMap

[#reference-filter]
==== filter

__Summary__::

Filter passes through all instances of the output type that match a provided closure, dropping any that don't match.

__Constraints on connected publisher__::

* requires Failure type to be `<Never>`

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/filter[`filter`]

__Usage__::

* <<reference.adoc#patterns-update-interface-network-request>>
* unit tests illustrating using filter: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilterPublisherTests.swift[`UsingCombineTests/FilterPublisherTests.swift`]

__Details__::

Filter takes a single closure as a parameter that is provided the value from the previous publisher and returns a Bool value.
If the return from the closure is `true`, then the operator republishes the value further down the chain.
If the return from the closure is `false`, then the operator drops the value.

If you need a variation of this that will generate an error condition in the pipeline to be handled use the <<#reference-tryFilter>> operator, which allows the closure to throw an error in the evaluation.

[#reference-tryFilter]
==== tryFilter

__Summary__::

tryFilter passes through all instances of the output type that match a provided closure, dropping any that don't match, and allows generating an error during the evaluation of that closure.

__Constraints on connected publisher__::

* none

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/tryfilter[`tryFilter`]

__Usage__::

* unit tests illustrating using tryFilter: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/FilterPublisherTests.swift[`UsingCombineTests/FilterPublisherTests.swift`]


__Details__::

Like <<#reference-filter>>, tryFilter takes a single closure as a parameter that is provided the value from the previous publisher and returns a Bool value.
If the return from the closure is `true`, then the operator republishes the value further down the chain.
If the return from the closure is `false`, then the operator drops the value.
You can additionally throw an error during the evaluation of tryFilter, which will then be propogated as the failure type down the pipeline.

[#reference-removeDuplicates]
==== removeDuplicates

__Summary__::

removeDuplicates remembers what was previously sent in the pipeline, and only passes forward values that don't match the current value.

__Constraints on connected publisher__::

* Available when Output of the previous publisher conforms to Equatable.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/removeduplicates[`removeDuplicates`]

__Usage__::

* unit tests illustrating using removeDuplicates: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/debounceAndRemoveDuplicatesPublisherTests.swift[`UsingCombineTests/debounceAndRemoveDuplicatesPublisherTests.swift`]

__Details__::

The default usage of removeDuplicates doesn't require any parameters, and the operator will publish only elements that don't match the previously sent element.

[source, swift]
----
.removeDuplicates()
----

A second usage of removeDuplicates takes a single parameter `by` that accepts a closure that allows you to determine the logic of what will be removed.
The parameter version does not have the constraint on the Output type being equatable, but requires you to provide the relevant logic.
If the closure returns true, the removeDuplicates predicate will consider the values matched and not forward a the duplicate value.

[source, swift]
----
.removeDuplicates(by: { first, second -> Bool in
    // your logic is required if the output type doesn't conform to equatable.
    first.id == second.id
})
----

A variation of removeDuplicates exists that allows the predicate closure to throw an Error exists: <<#reference-tryremoveduplicates>>

[#reference-tryremoveduplicates]
==== tryRemoveDuplicates

__Summary__::

tryRemoveDuplicates is a variant of <<#reference-removeduplicates>> that allows the predicate testing equality to throw an Error, resulting in an Error completion type.

__Constraints on connected publisher__::

* none

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/tryremoveduplicates[`tryRemoveDuplicates`]

__Usage__::

* unit tests illustrating using tryRemoveDuplicates: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/debounceAndRemoveDuplicatesPublisherTests.swift[`UsingCombineTests/debounceAndRemoveDuplicatesPublisherTests.swift`]

__Details__::

tryRemoveDuplicates is a variant of <<#reference-removeduplicates>> taking a single parameter that can throw an error.
The parameter is a closure that allows you to determine the logic of what will be removed.
If the closure returns true, tryRemoveDuplicates will consider the values matched and not forward a the duplicate value.
If the closure throws an error, a failure completion will be propogated down the chain, and no value is sent.

[source, swift]
----
.removeDuplicates(by: { first, second -> Bool throws in
    // your logic is required if the output type doesn't conform to equatable.

})
----

[#reference-replaceEmpty]
==== replaceEmpty

* replaceEmpty
** requires Failure to be `<Never>`

[#reference-replaceError]
==== replaceError

* replaceError
** requires Failure to be `<Never>`

[#reference-replaceNil]
==== replaceNil

* replaceNil
** requires Failure to be `<Never>`
** Replaces nil elements in the stream with the proviced element.

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-reducing]
=== Reducing elements

[#reference-collect]
==== collect
* collect
** multiple variants
*** buffers items
*** `collect()` Collects all received elements, and emits a single array of the collection when the upstream publisher finishes.
*** `collect(Int)` collects N elements and emits as an array
*** `collect(.byTime)` or `collect(.byTimeOrCount)`

[#reference-collectByCount]
==== collectByCount

* collectByCount

[#reference-collectByTime]
==== collectByTime

* collectByTime

[#reference-ignoreOutput]
==== ignoreOutput

* ignoreOutput

[#reference-reduce]
==== reduce

* reduce
** A publisher that applies a closure to all received elements and produces an accumulated value when the upstream publisher finishes.
** requires Failure to be `<Never>`
** there's a varient `tryReduce` for use with a provided error-throwing closure.


[#reference-tryReduce]
==== tryReduce

* tryReduce

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-mathematical]
=== Mathematic opertions on elements

[#reference-max]
==== max

* max
** Available when Output conforms to Comparable.
** Publishes the maximum value received from the upstream publisher, after it finishes.

[#reference-min]
==== min
** Publishes the minimum value received from the upstream publisher, after it finishes.
** Available when Output conforms to Comparable.


[#reference-comparison]
==== comparison

* comparison
** republishes items from another publisher only if each new item is in increasing order from the previously-published item.
** there's a variant `tryComparson` which fails if the ordering logic throws an error

[#reference-tryComparison]
==== tryComparison

* tryComparison

[#reference-count]
==== count

* count
** publishes the number of items received from the upstream publisher

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-criteria]
=== Applying matching criteria to elements

[#reference-allSatisfy]
==== allSatisfy

* allSatisfy
** Publishes a single Boolean value that indicates whether all received elements pass a given predicate.
** there's a variant `tryAllSatisfy` when the predicate can throw errors

[#reference-tryAllSatisfy]
==== tryAllSatisfy

* tryAllSatisfy

[#reference-contains]
==== contains

* contains
** emits a Boolean value when a specified element is received from its upstream publisher.
** variant `containsWhere` when a provided predicate is satisfied
** variant `tryContainsWhere` when a provided predicate is satisfied but could throw errors

[#reference-containsWhere]
==== containsWhere

* containsWhere

[#reference-tryContainsWhere]
==== tryContainsWhere

* tryContainsWhere

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-sequence]
=== Applying sequence operations to elements

[#reference-first]
==== first

* first
** requires Failure to be `<Never>`
** publishes the first element to satisfy a provided predicate

[#reference-firstWhere]
==== firstWhere

* firstWhere

[#reference-tryFirstWhere]
==== tryFirstWhere

* tryFirstWhere

[#reference-last]
==== last

* last
** requires Failure to be `<Never>`
** publishes the last element to satisfy a provided predicate

[#reference-lastWhere]
==== lastWhere
* lastWhere

[#reference-tryLastWhere]
==== tryLastWhere

* tryLastWhere

[#reference-dropUntilOutput]
==== dropUntilOutput

* dropUntilOutput

[#reference-dropWhile]
==== dropWhile

* dropWhile

[#reference-tryDropWhile]
==== tryDropWhile

* tryDropWhile

[#reference-concatenate]
==== concatenate

* concatenate

[#reference-drop]
==== drop
* drop
** multiple variants
** requires Failure to be `<Never>`
** Ignores elements from the upstream publisher until it receives an element from a second publisher.
** or `drop(while: {})`

[#reference-prefixUntilOutput]
==== prefixUntilOutput

* prefixUntilOutput
** Republishes elements until another publisher emits an element.
** requires Failure to be `<Never>`

[#reference-prefixWhile]
==== prefixWhile

* prefixWhile
** Republishes elements until another publisher emits an element.
** requires Failure to be `<Never>`

[#reference-tryPrefixWhile]
==== tryPrefixWhile

* tryPrefixWhile
** Republishes elements until another publisher emits an element.
** requires Failure to be `<Never>`

[#reference-output]
==== output

* output

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-combinepublishers]
=== Combining elements from multiple publishers

[#reference-combineLatest]
==== combineLatest

* combineLatest
** brings inputs from 2 (or more) streams together
** you provide a closure that gets the values and chooses what to publish

[#reference-tryCombineLatest]
==== tryCombineLatest

* tryCombineLatest

[#reference-merge]
==== merge

* merge

** Combines elements from this publisher with those from another publisher of the same type, delivering an interleaved sequence of elements.
** requires Failure to be `<Never>`
** multiple variants that will merge between 2 and 8 different streams

[#reference-zip]
==== zip

* zip
** Combine elements from another publisher and deliver pairs of elements as tuples.
** requires Failure to be `<Never>`

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-handlingErrors]
=== Handling errors

See <<patterns.adoc#patterns-general-error-handling>> for more detail on how you can design error handling.

[#reference-catch]
==== catch

__Summary__::

The operator `catch` handles errors (completion messages of type `.failure`) from an upstream publisher by replacing the failed publisher with another publisher.
The operator also transforms the Failure type to `<Never>`.

__Constraints on connected publisher__::

* __none__

__icon:apple[] Documentation reference__:: https://developer.apple.com/documentation/combine/publishers/catch[`Publishers.Catch`]

__Usage__::

* <<patterns.adoc#patterns-oneshot-error-handling>> shows an example of using `catch` to handle errors with a one-shot publisher.
* <<patterns.adoc#patterns-continual-error-handling>> shows an example of using `catch` with `flatMap` to handle errors with a continual publisher.
* <<patterns.adoc#patterns-update-interface-network-request>>

__Details__::

Once catch receives a `.failure` completion, it won't send any further incoming values from the original upstream publisher.
You can also view catch as a switch that only toggles in one direction: to using a new publisher that you define, but only when the original publisher to which it is subscribed sends an error.

This can be illustrated with the following code snippet:

[source, swift]
----
enum testFailureCondition: Error {
    case invalidServerResponse
}

let simplePublisher = PassthroughSubject<String, Error>()

let _ = simplePublisher
    .catch { err in
        // must return a Publisher
        return Just("replacement value")
    }
    .sink(receiveCompletion: { fini in
        print(".sink() received the completion:", String(describing: fini))
    }, receiveValue: { stringValue in
        print(".sink() received \(stringValue)")
    })

simplePublisher.send("oneValue")
simplePublisher.send("twoValue")
simplePublisher.send(completion: Subscribers.Completion.failure(testFailureCondition.invalidServerResponse))
simplePublisher.send("redValue")
simplePublisher.send("blueValue")
simplePublisher.send(completion: .finished)
----

In this example, we are using a `PassthroughSubject` so that we can control when and what gets sent from the publisher.
In the above code, we are sending two good values, then a failure, then attempting to send two more good values.
The values you would see printed from our `.sink()` closures are:

[source]
----
.sink() received oneValue
.sink() received twoValue
.sink() received replacement value
.sink() received the completion: finished
----

When the failure was sent through the pipeline, catch intercepts it and returns "replacement value" as expected.
The replacement publisher it used (`Just`) sends a single value and then sends a completion.
If we want the pipeline to remain active, we need to change how we handle the errors.

[#reference-tryCatch]
==== tryCatch

__Summary__::

A variant of the <<#reference-catch>> operator that also allows an `<Error>` failure type, and doesn't convert the failure type to `<Never>`.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/trycatch

__Usage__::

* <<patterns.adoc#patterns-constrained-network>>

__Details__::

`tryCatch` is a variant of <<#reference-catch>> that has a failure type of `<Error>` rather than catch's failure type of `<Never>`.
This allows it to be used where you want to immediately react to an error by creating another publisher that may also produce a failure type.

[#reference-assertNoFailure]
==== assertNoFailure

__Summary__::

Raises a fatal error when its upstream publisher fails, and otherwise republishes all received input and converts failure type to `<Never>`.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/assertnofailure

__Usage__::

* <<patterns.adoc#patterns-assertNoFailure>>

__Details__::

If you need to verify that no error has occured (treating the error output as an invariant), this is the operator to use.
Like it's namesakes, it will cause the program to terminate if the assert is violated.

Adding it into the pipeline requires no additional parameters, but you can include a string:

[source, swift]
----
.assertNoFailure()
// OR
.assertNoFailure("What could possibly go wrong?")
----

[NOTE]
====
I'm not entirely clear on where that string would appear if you did include it.

When trying out this code in unit tests, the tests invariably drop into a debugger at the assertion point when a .failure is processed through the pipeline.
====

If you want to convert an failure tyoe output of `<Error>` to `<Never>`, you probably want to look at the <<#reference-catch>> operator.

Apple asserts this function should be primarily used for testing and verifying "internal sanity checks that are active during testing".

[#reference-retry]
==== retry

__Summary__::

The retry opeator is used to repeat requests to a previous publisher in the event of an error.

__Constraints on connected publisher__::

* failure type must be `<Error>`

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/retry

__Usage__::

* <<patterns.adoc#patterns-retry>>
* unit tests illustrating using map with dataTaskPublisher: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift[`UsingCombineTests/DataTaskPublisherTests.swift`]
* unit tests illustrating retry: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/RetryPublisherTests.swift[`UsingCombineTests/RetryPublisherTests.swift`]

__Details__::

When you specify this operator in a pipeline and it receives a subscription, it first tries to request a subscription from it's upstream publisher.
If the response to that subscription fails, then it will retry the subscription to the same publisher.

The retry operator accepts an optional (but recommended) single parameter that specifies a number of retries to attempt.
If no number of retries is specified, it will attempt to retry indefinitely until it receives a .finished completion from it's subscriber.

[NOTE]
====
Using retry without any specific count can result in your pipeline never resolving any data or completions.
If you use retry without a count, you may also want to use the <<#reference-timeout>> operator to force a completion from the pipeline.
====

If the number of retries is specified and all requests fail, then the `.failure` completion is passed down to the subscriber of this operator.

In practice, this is mostly commonly desired when attempting to request network resources with an unstable connection.
If you use a retry operator, you should add a specific number of retries so that the subscription doesn't effectively get into an infinite loop.

[source, swift]
----
struct IPInfo: Codable {
    // matching the data structure returned from ip.jsontest.com
    var ip: String
}
let myURL = URL(string: "http://ip.jsontest.com")
// NOTE(heckj): you'll need to enable insecure downloads in your Info.plist for this example
// since the URL scheme is 'http'

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .retry(3)
    // if the URLSession returns a .failure completion, try at most 3 times to get a successful response
    .map({ (inputTuple) -> Data in
        return inputTuple.data
    })
    .decode(type: IPInfo.self, decoder: JSONDecoder())
    .catch { err in
        return Publishers.Just(IPInfo(ip: "8.8.8.8"))
    }
    .eraseToAnyPublisher()
----

[#reference-mapError]
==== mapError

* mapError
** Converts any failure from the upstream publisher into a new error.

[#reference-operators-adaptingTypes]
=== Adapting publisher types

[#reference-switchToLatest]
==== switchToLatest

__Summary__::

A publisher that flattens any nested publishers, using the most recent provided publisher.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/switchtolatest

__Usage__::

* <<reference.adoc#patterns-update-interface-network-request>>
* unit tests illustrating switchToLatest: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SwitchAndFlatMapPublisherTests.swift[`UsingCombineTests/SwitchAndFlatMapPublisherTests.swift`]

__Details__::

switchToLatest is akin to <<#reference-flatmap>>, taking in a publisher instance and returning it's value (or values).
The primary different is in where it gets the publisher.
In flatMap, the publisher is returned within the closure provided to flatMap, and the operator works upon that to subscribe and provide the relevant value down the pipeline.
In switchToLatest, the publisher instance is provided *as the output type* from a previous publisher or operator.

The most common form of using this is with a one-shot publisher such as <<#reference-just>>, <<#reference-once>>, or getting it's value as a result of a <<#reference-map>> transform.

It is also commonly used when working with an API that provides a publisher.
switchToLatest assists in taking the result of the publisher and sending that down the pipeline rather than sending the publisher itself down as the output type.

The following snippet is part of the larger example <<reference.adoc#patterns-update-interface-network-request>>

[source, swift]
----
.map { username -> AnyPublisher<[GithubAPIUser], Never> in <2>
    return GithubAPI.retrieveGithubUser(username: username) <1>
}
// ^^ type returned in the pipeline is a Publisher, so we use
// switchToLatest to flatten the values out of that
// pipline to return down the chain, rather than returning a
// publisher down the pipeline.
.switchToLatest() <2>
----

<1> In this example, an API instance (GithubAPI) has a function that returns a publisher.
<2> We are using <<#reference-map>> to take an earlier String output type and use that to invoke the API, which returns a publisher instance.
<3> We want to use the value from that publisher, not the publisher itself, which is exactly what switchToLatest() provides.

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-timing]
=== Controlling timing

[#reference-debounce]
==== debounce

* debounce
** `.debounce(for: 0.5, scheduler: RunLoop.main)`
** collapses multiple values within a specified time window into a single value
** often used with `.removeDuplicates()`

[#reference-delay]
==== delay

* delay
** Delays delivery of all output to the downstream receiver by a specified amount of time on a particular scheduler.
** requires Failure to be `<Never>`

[#reference-measureInterval]
==== measureInterval

* measureInterval
** Measures and emits the time interval between events received from an upstream publisher.
** requires Failure to be `<Never>`

[#reference-throttle]
==== throttle

* throttle
** Publishes either the most-recent or first element published by the upstream publisher in the specified time interval.
** requires Failure to be `<Never>`

[#reference-timeout]
==== timeout

__Summary__::

Terminates publishing if the upstream publisher exceeds the specified time interval without producing an element.

__Constraints on connected publisher__::

* requires Failure to be `<Never>`

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/timeout

__Usage__::

* unit tests illustrating using retry and timeout with dataTaskPublisher: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/DataTaskPublisherTests.swift[`UsingCombineTests/DataTaskPublisherTests.swift`]

__Details__::

Timeout will force a resolution to a pipeline after a given amount of time, but does not guarantee either data or errors, only a completion.
If a timeout does trigger and force a completion, it will not generate an failure completion with an error.

Timeout is specified with two parameters, a time period and a scheduler.

If you are using a specific background thread (for example, with the <<#reference-subscribe>> operator), then timeout should likely be using the same scheduler.

The time period specified will take a literal integer, but otherwise needs to conform to the protocol https://developer.apple.com/documentation/combine/schedulertimeintervalconvertible[SchedulerTimeIntervalConvertible].
If you want to set a number from a Float or Int, you need to create the relevant structure, as Int or Float directly doesn't conform.
For example, if you're using a DispatchQueue, you could use https://developer.apple.com/documentation/dispatch/dispatchqueue/schedulertimetype/stride[DispatchQueue.SchedulerTimeType.Stride].

[source, swift]
----
let remoteDataPublisher = urlSession.dataTaskPublisher(for: self.mockURL!)
    .delay(for: 2, scheduler: backgroundQueue)
    .retry(5) // 5 retries, 2 seconds each ~ 10 seconds for this to fall through
    .timeout(5, scheduler: backgroundQueue) // max time of 5 seconds before failing
    .tryMap { data, response -> Data in
        guard let httpResponse = response as? HTTPURLResponse,
            httpResponse.statusCode == 200 else {
                throw testFailureCondition.invalidServerResponse
        }
        return data
    }
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder())
    .subscribe(on: backgroundQueue)
    .eraseToAnyPublisher()
----

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-coding]
=== Encoding and decoding

[#reference-encode]
==== encode

__Summary__::

Encode converts the output from upstream Encodable object using a specified TopLevelEncoder. For example, use JSONEncoder or PropertyListEncoder..

__Constraints on connected publisher__::

* Available when Output conforms to Encodable.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/encode

__Usage__::

* unit tests illustrating using encode and decode: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EncodeDecodeTests.swift[`UsingCombineTests/EncodeDecodeTests.swift`]


__Details__::

The encode operator takes a single parameters:

* `encoder` an instance of an object conforming to https://developer.apple.com/documentation/combine/toplevelencoder[TopLevelEncoder], frequently an instance of https://developer.apple.com/documentation/foundation/jsonencoder[JSONEncoder]() or https://developer.apple.com/documentation/foundation/propertylistencoder[PropertyListEncoder]().

[source, swift]
----
fileprivate struct PostmanEchoTimeStampCheckResponse: Codable {
    let valid: Bool
}

let dataProvider = PassthroughSubject<PostmanEchoTimeStampCheckResponse, Never>()
    .encode(encoder: JSONEncoder())
    .sink { data in
        print(".sink() data received \(data)")
        let stringRepresentation = String(data: data, encoding: .utf8)
        print(stringRepresentation)
    })
----

Like the <<#reference-decode>> operator, the encode process can also fail and throw an error, so it returns a failure type of Error.
With the compiler forcing type matching, the usual error condition is if you flow an optional value into the pipeline.

[#reference-decode]
==== decode

__Summary__::

A very common operation is to want to use decode (or <<#reference-encode>> data in a pipline, so Combine provides an operator specifically suited to that task.

__Constraints on connected publisher__::

* Available when Output conforms to Decodable.

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publishers/decode

__Usage__::

* <<patterns.adoc#patterns-dataTaskPublisher-decode>>
* <<patterns.adoc#patterns-dataTaskPublisher-tryMap>>
* <<patterns.adoc#patterns-oneshot-error-handling>>
* <<patterns.adoc#patterns-retry>>
* unit tests illustrating using encode and decode: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/EncodeDecodeTests.swift[`UsingCombineTests/EncodeDecodeTests.swift`]


__Details__::

The decode operator takes two parameters:

* `type` which is typically a reference to a struct you've defined
* `decoder` an instance of an object conforming to https://developer.apple.com/documentation/combine/topleveldecoder[TopLevelDecoder], frequently an instance of https://developer.apple.com/documentation/foundation/jsondecoder[JSONDecoder]() or https://developer.apple.com/documentation/foundation/propertylistdecoder[PropertyListDecoder]().

Since decoding can fail, the operator will also return a failure type of Error.
The data type returned by the operator is defined by the type you provided to decode.

[source, swift]
----
let testUrlString = "https://postman-echo.com/time/valid?timestamp=2016-10-10"
// checks the validity of a timestamp - this one should return {"valid":true}
// matching the data structure returned from https://postman-echo.com/time/valid
fileprivate struct PostmanEchoTimeStampCheckResponse: Decodable, Hashable {
    let valid: Bool
}

let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: URL(string: testUrlString)!)
    // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
    .map { $0.data }
    .decode(type: PostmanEchoTimeStampCheckResponse.self, decoder: JSONDecoder())
----

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-operators-multipleSubscribers]
=== Working with multiple subscribers

[#reference-multicast]
==== multicast

* multicast

[#reference-operators-debugging]
=== Debugging

[#reference-breakpoint]
==== breakpoint

* breakpoint
** Raises a debugger signal when a provided closure needs to stop the process in the debugger.

[#reference-breakpointOnError]
==== breakpointOnError

* breakpointOnError
** Raises a debugger signal upon receiving a failure.

[#reference-handleEvents]
==== handleEvents

* handleEvents

[#reference-print]
==== print

* print
** Prints log messages for all publishing events.
** requires Failure to be `<Never>`

// force a page break - in HTML rendering is just a <HR>
<<<
'''

=== Scheduler and Thread handling operators

[#reference-receive]
==== receive

__Summary__::

Receive defines the scheduler on which to receive elememts from the publisher.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/publisher/3204743-receive[`receive`]

__Usage__::

* <<patterns.adoc#patterns-assign-subscriber>> shows an example of using assign to set an a boolean property on a UI element.
* unit tests illustrating using an assign subscriber in a pipeline from a dataTaskPublisher with subscribe and receive: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift[`UsingCombineTests/SubscribeReceiveAssignTests.swift`]

__Details__::

Receive takes a single required parameter (`on:`) which accepts a scheduler, and an optional parameter (`optional:`) which can accept SchedulerOptions.
https://developer.apple.com/documentation/combine/scheduler[Scheduler] is a protocol in Combine, with the conforming types that are commonly used of https://developer.apple.com/documentation/foundation/runloop[RunLoop], https://developer.apple.com/documentation/dispatch/dispatchqueue[DispatchQueue] and https://developer.apple.com/documentation/foundation/operationqueue[OperationQueue].
Receive is frequently used with <<#reference-assign>> to make sure any following pipeline invocations happen on a specific thread, such as `RunLoop.main` when updating user interface objects.
Receive effects itself and any opertors chained after it, but not previous operators.
If you want to influence previously chained publishers (or operators) for where to run, use the <<#reference-subscribe>> operator.

[source, swift]
----
examplePublisher.receive(on: RunLoop.main)
----

Receive takes a single
[#reference-subscribe]
==== subscribe

__Summary__::

Subscribe defines the scheduler on which to run operators in a pipeline.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/anypublisher/3204260-subscribe[`subscribe`]


__Usage__::

* <<patterns.adoc#patterns-assign-subscriber>> shows an example of using assign to set an a boolean property on a UI element.
* unit tests illustrating using an assign subscriber in a pipeline from a dataTaskPublisher with subscribe and receive: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift[`UsingCombineTests/SubscribeReceiveAssignTests.swift`]

__Details__::

Subscribe assigns a scheduler to any preceding pipeline invocations, and is often used to invoke a publisher on a background thread or queue. When used in this fashion, it is often used in coordination with <<#reference-receive>> to transfer data to another thread (such as the main runloop) for following operators or the subscriber.

Subscribe takes a single required parameter (`on:`) which accepts a scheduler, and an optional parameter (`optional:`) which can accept SchedulerOptions.
https://developer.apple.com/documentation/combine/scheduler[Scheduler] is a protocol in Combine, with the conforming types that are commonly used of https://developer.apple.com/documentation/foundation/runloop[RunLoop], https://developer.apple.com/documentation/dispatch/dispatchqueue[DispatchQueue] and https://developer.apple.com/documentation/foundation/operationqueue[OperationQueue].

Subscribe effects itself and any opertors chained before it, but not following operators.
If you want to influence chained operators after subscribe for where to run, use the <<#reference-receive>> operator.
The most comon example of this is receiving on `RunLoop.main`, critical when updating user interface objects.

[source, swift]
----
networkDataPublisher
    .subscribe(on: backgroundQueue) <1>
    .receive(on: RunLoop.main) <2>
    .assign(to: \.text, on: yourLabel) <3>
----

<1> the `subscribe` call requests the publisher (and any pipeline invocations before this in a chain) be invoked on the backgroundQueue.
<2> the `receive` call transfers the data to the main runloop, suitable for updating user interface elements
<3> the `assign` call uses the <<#reference-assign>> subscriber to update the property `text` on a KVO compliant object, in this case `yourLabel`.

[NOTE]
====
When creating a DispatchQueue to use with Combine publishers on background threads, it is recommended that you use a regular serial queue rather than a concurrent queue https://forums.swift.org/t/runloop-main-or-dispatchqueue-main-when-using-combine-scheduler/26635/4[to allow Combine to adhere to its contracts].
That is - don't create the queue with `attributes: .concurrent`.
====

// force a page break - in HTML rendering is just a <HR>
<<<
'''

=== Type erasure operators

[#reference-eraseToAnyPublisher]
==== eraseToAnyPublisher

** when you chain operators together in swift, the object's type signature accumulates all the various types, and it gets ugly pretty quickly.
** eraseToAnyPublisher takes the signature and "erases" the type back to the common type of AnyPublisher
** this provides a cleaner type for external declarations (framework was created prior to Swift 5's opaque types)
** `.eraseToAnyPublisher()`
** often at the end of chains of operators, and cleans up the type signature of the property getting asigned to the chain of operators

[#reference-eraseToAnySubscriber]
==== eraseToAnySubscriber

[#reference-eraseToAnySubject]
==== eraseToAnySubject

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-subjects]
== Subjects

//xref to coreconcepts - subjects

[#reference-currentValueSubject]
=== currentValueSubject

* https://developer.apple.com/documentation/combine/currentvaluesubject[`CurrentValueSubject`]

[#reference-passthroughSubject]
=== PassthroughSubject

* https://developer.apple.com/documentation/combine/passthroughsubject[`PassthroughSubject`]

// force a page break - in HTML rendering is just a <HR>
<<<
'''

[#reference-subscribers]
== Subscribers

For general information about subscribers and how they fit with publishers and operators, see <<coreconcepts.adoc#core-subscribers>>.

[#reference-assign]
=== assign

__Summary__::

Assign creates a subscriber used to update a property on a KVO compliant object.

__Constraints on connected publisher__::

* Failure type must be `<Never>`

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/subscribers/assign[`assign`]

__Usage__::

* <<patterns.adoc#patterns-assign-subscriber>> shows an example of using assign to set an a boolean property on a UI element.
* unit tests illustrating using an assign subscriber in a pipeline from a dataTaskPublisher with subscribe and receive: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SubscribeReceiveAssignTests.swift[`UsingCombineTests/SubscribeReceiveAssignTests.swift`]

__Details__::

Assign only handles data, and expects all errors or failures to be handled in the pipeline before it is invoked.
The return value from setting up assign can be cancelled, and is frequently used when disabling the pipeline, such as when a viewController is disabled or deallocated.
Assign is frequently used in conjunction with the <<#reference-receive>> operator to receive values on a specific scheduler, typically `RunLoop.main` when updating UI objects.

[source, swift]
----
examplePublisher
    .receive(on: RunLoop.main) <2>
    .assign(to: \.text, on: yourLabel) <3>
----

[#reference-sink]
=== sink

__Summary__::

Sink creates an all-purpose subscriber.
At a minimum, you provide a closure to receive values, and optionally a closure that receives completions.

__Constraints on connected publisher__::

* __none__

__icon:apple[] docs__:: https://developer.apple.com/documentation/combine/subscribers/sink[`sink`]

__Usage__::

* <<patterns.adoc#patterns-sink-subscriber>> shows an example of creating a sink that receives both completion messages as well as data from the publisher.
* unit tests illustrating a sink subscriber and how it works: https://github.com/heckj/swiftui-notes/blob/master/UsingCombineTests/SinkSubscriberTests.swift[`UsingCombineTests/SinkSubscriberTests.swift`]

__Details__::

The simplest form of `.sink()` takes a single closure - by default this closure receives data (if provided by the attached publisher).

[source, swift]
----
let examplePublisher = Just(5)

let _ = examplePublisher.sink { value in
    print(".sink() received \(String(describing: value))")
}
----

The closure you provide is invoked for every update that the publisher passes down, up until the completion.
Be aware that the single closure form may be called repeatedly.
How often it is called depends on the pipeline to which it is subscribing.

If you don't also include a closure to get the completion, you will not receive any information about failures.
If an error or failure occurs and is handed down from the publisher the single closure form will not be called.

If you are creating a subscriber and want to receive failures, or see the completion messages at the end of pipeline, create a sink with two closures.
The more complete sink has the two closures named `receiveCompletion` and `receiveValue`:

[source, swift]
----
let examplePublisher = Just(5)

let _ = examplePublisher.sink(receiveCompletion: { err in
    print(".sink() received the completion", String(describing: err))
}, receiveValue: { value in
    print(".sink() received \(String(describing: value))")
})
----

The type that is passed into receiveCompletion is the enum https://developer.apple.com/documentation/combine/subscribers/completion[`Subscribers.Completion`].
The completion `.failure` incudes an Error wrapped within it, providing access to the underlying cause of the failure.
To get to the error within the `.failure` completion, `switch` on the returned completion to determine if it is `.finished` or `.failure`, and then pull out the error.

When you chain a `.sink` subscriber onto a publisher (or pipeline), the result is cancellable.
At any time before the publisher sends a completion, the subscriber can send a cancellation and invalidate the pipeline.
After a cancel is sent, no further values will be received by either closure in the sink.

[source,swift]
----
let simplePublisher = PassthroughSubject<String, Error>()
let cancellablePipeline = simplePublisher.sink { data in
  // do what you need with the data...
}

cancellablePublisher.cancel() // this invalidates the pipeline, no further data will be received by the sink
----

