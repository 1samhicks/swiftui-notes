[#coreconcepts]
= Core Concepts

Two key concepts, described in swift with protocols, are the https://developer.apple.com/documentation/combine/publisher[*publisher*] and the https://developer.apple.com/documentation/combine/subscriber[*subscriber*].

A publisher provides data.
It is described with two associated types: one for Output and one for Failure.

A subscriber requests data.
It is also described with two associated types, one for Input and one for Failure.

When you connect a subscriber to a publisher, both types must match: Output to Input, and Failure to Failure.
You can view this as a series of operations on two types in parallel.

[source]
----
Publisher source       Subscriber
+--------------+      +--------------+
|        <Output> --> <Input>        |
|       <Failure> --> <Failure>      |
+--------------+      +--------------+
----

Operators are classes that adopt the https://developer.apple.com/documentation/combine/publisher[Publisher protocol], subscribing to one or more Publishers, and sending results to one (or more) Subscribers.

You can create chains of these together, for processing, reacting, and transforming the data provided by a publisher, and requested by the subscriber.

I'm calling these composed sequences **pipelines**.

[source]
----
Publisher source       Operator                          Subscriber
+--------------+      +---------------------------+      +--------------+
|        <Output> --> <Input>      map      <Output> --> <Input>        |
|       <Failure> --> <Failure>  function  <Failure> --> <Failure>      |
+--------------+      +---------------------------+      +--------------+
----


Operators can be used to transform types - both the Output and Failure type.
Operators may also split or duplicate streams, or merge streams together.
Operators must always be aligned by the combination of Output/Failure types.

A simple pipeline, using Combine, might look like:
[source, swift]
----
let _ = Publishers.somePublisher
    .map { value -> String in
        // do something with the incoming value here
        // and return a string
        return "a string"
    }
    .sink { receivedValue in
        // sink is the subscriber and terminates the pipeline
        print("The end result was \(receivedValue)")
    }
----


The compiler will enforce the matching types.
When you are viewing a pipeline, or creating one, you can think of it as a sequence of operations linked by the types.

[source, swift]
----
let _ = Publishers.Just(5) <1>
    .map { value -> String in <2>
        switch value {
        case _ where value < 1:
            return "none"
        case _ where value == 1:
            return "one"
        case _ where value == 2:
            return "couple"
        case _ where value == 3:
            return "few"
        case _ where value > 8:
            return "many"
        default:
            return "some"
        }
    }
    .sink { receivedValue in <3>
        print("The end result was \(receivedValue)")
    }
----
<1> creates an `<Int>`, `<Never>` type combination
<2> the `.map()` function takes in an `<Int>`, `<Never>` combination and transforms it into a `<String>`,
<3> receives the `<String>`, `<Never>` combination

Because the types are enforced, there are a number of Combine functions that are created to help with these transformations.
Some operators are prefixed with `try` that indicate that they will return an <Error> type.
In other cases, you will just need to define the type being returned in the closure you're providing to the operator.

[sidebar]
****
When you are creating pipelines in Xcode, you will likely get assistance in the form of error messages like: `Unable to infer complex closure return type; add explicit type to disambiguate`.
****

Combine supports error handling by creating two streams - one for the functional case and one for the error case, and combining them together.
We will see that in more detail in the section on patterns.

== The lifecycle of Publishers and Subscribers

The interals of Combine are all driven by the subscriber.
This is how Combine supports the concept of back pressure.

Internally, Combine supports this with the enumeration https://developer.apple.com/documentation/combine/subscribers/demand[Demand].
When a subscriber is communicating with a publisher, it requests based on demand.
This request is what drives calling all the closures up the composed pipeline.

Because subscribers drive the closure execution, it also allows Combine to support cancellation.
Cancellation can be triggered by the subscriber.

This is all built on subscribers and publishers communicating in a well defined sequence, or lifecycle.

* When the subscriber is attached to a publisher, it starts with a call to `.subscribe(Subscriber)`.
* The publisher in turn acknowledges the subscription calling `receive(subscription)`.

** After the subscription has been acknowledged, the subscriber requests _N_ values with `request(_ : Demand)`.
** The publisher may then (as it has values) sending _N_ (or fewer) values: `receive(_ : Input)`.
A publisher should never send **more** than the demand requested.
** Also after the subscription has been acknowledged, the subscriber can send a https://developer.apple.com/documentation/combine/subscribers/completion[cancellation] with `.cancel()`

* A publisher may optionally send https://developer.apple.com/documentation/combine/subscribers/completion[completion]: `receive(completion:)` which is also how errors are propogated.

== Publishers

The publisher is the provider of data.
The https://developer.apple.com/documentation/combine/publisher[publisher protocol] has a strict contract returning values, or terminating with an explicit completion enumeration.

Combine provides a number of convenience publishers:

* Publishers.Empty
* Publishers.Fail
* Publishers.Just
* Publishers.Once
* Publishers.Optional
* Publishers.Sequence
* Publishers.Deferred

Combine allows you to create a publisher with the https://developer.apple.com/documentation/combine/published[`@Published`] property wrapper to provide a publisher for a specific property.

SwiftUI provides https://developer.apple.com/documentation/swiftui/objectbinding[`@ObjectBinding`] which can be used to create a publisher.

A number of other Apple APIs provide publishers as well:

* https://developer.apple.com/documentation/foundation/notificationcenter[`NoticationCenter`] https://developer.apple.com/documentation/foundation/notificationcenter/3329353-publisher[`.publisher`]

* https://developer.apple.com/documentation/foundation/timer[`Timer`] https://developer.apple.com/documentation/foundation/notificationcenter/3329353-publisher[`.publish`] and https://developer.apple.com/documentation/foundation/timer/timerpublisher[`Timer.TimerPublisher`]

* https://developer.apple.com/documentation/foundation/urlsession[`URLSession`] https://developer.apple.com/documentation/foundation/urlsession/3329707-datataskpublisher[`dataTaskPublisher`]

* https://developer.apple.com/documentation/realitykit[`RealityKit`] https://developer.apple.com/documentation/realitykit/scene[`.Scene`] https://developer.apple.com/documentation/realitykit/scene/3254685-publisher[`.publisher()`]

Combine also includes mechanisms to allow you to create your own publishers with `Publishers.Future`. A future is initialized with a closure that eventually resolves to a https://developer.apple.com/documentation/combine/publishers/future/promise[Promise]. This can be used to wrap any existing API (Apple or your own) that provides a completion closure to turn it into a publisher.


== Operators


== Subjects

== Subscribers


